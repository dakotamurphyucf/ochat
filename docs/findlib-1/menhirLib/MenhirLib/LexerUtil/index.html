<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LexerUtil (docs.findlib-1.menhirLib.MenhirLib.LexerUtil)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../../';
let search_urls = ['../../../../db.js','../../../../sherlodoc.js'];
</script><script src="../../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">Index</a> &#x00BB; <a href="../../../../index.html">docs</a> &#x00BB; <a href="../../../index.html">findlib-1</a> &#x00BB; <a href="../../index.html">menhirLib</a> &#x00BB; <a href="../index.html">MenhirLib</a> &#x00BB; LexerUtil</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>MenhirLib.LexerUtil</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../stdlib/Stdlib/Lexing/index.html#type-lexbuf">Lexing.lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../stdlib/Stdlib/Lexing/index.html#type-lexbuf">Lexing.lexbuf</a></span></code></div><div class="spec-doc"><p><code>init filename lexbuf</code> initializes the lexing buffer <code>lexbuf</code> so that the positions that are subsequently read from it refer to the file <code>filename</code>. It returns <code>lexbuf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span>string <span class="arrow">&#45;&gt;</span></span> string * <a href="../../../../stdlib/Stdlib/Lexing/index.html#type-lexbuf">Lexing.lexbuf</a></span></code></div><div class="spec-doc"><p><code>read filename</code> reads the entire contents of the file <code>filename</code> and returns a pair of this content (a string) and a lexing buffer that has been initialized, based on this string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-newline"><a href="#val-newline" class="anchor"></a><code><span><span class="keyword">val</span> newline : <span><a href="../../../../stdlib/Stdlib/Lexing/index.html#type-lexbuf">Lexing.lexbuf</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>newline lexbuf</code> increments the line counter stored within <code>lexbuf</code>. It should be invoked by the lexer itself every time a newline character is consumed. This allows maintaining a current the line number in <code>lexbuf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span><span>(<a href="../../../../stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a> * <a href="../../../../stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a>)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>range (startpos, endpos)</code> prints a textual description of the range delimited by the start and end positions <code>startpos</code> and <code>endpos</code>. This description is one line long and ends in a newline character. This description mentions the file name, the line number, and a range of characters on this line. The line number is correct only if <code>newline</code> has been correctly used, as described dabove.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tabulate"><a href="#val-tabulate" class="anchor"></a><code><span><span class="keyword">val</span> tabulate : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>tabulate is_eof lexer</code> tabulates the lexer <code>lexer</code>: that is, it immediately runs this lexer all the way until an EOF token is found, stores the tokens in an array in memory, and returns a new lexer which (when invoked) reads tokens from this array. The function <code>lexer</code> is not allowed to raise an exception, and must produce a finite stream of tokens: that is, after a finite number of invocations, it must return a token that is identified by the function <code>is_eof</code> as an EOF token.</p><p>Both the existing lexer <code>lexer</code> and the new lexer returned by <code>tabulate is_eof lexer</code> are functions of type <code>unit -&gt; 'a</code>, where the type <code>'a</code> is likely to be instantiated with a triple of a token and two positions, as per the revised lexer API described in the module <a href="../Convert/index.html"><code>Convert</code></a>.</p></div></div></div></body></html>
