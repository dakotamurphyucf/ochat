<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Soup (docs.findlib-1.lambdasoup.Soup)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../';
let search_urls = ['../../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">findlib-1</a> &#x00BB; <a href="../index.html">lambdasoup</a> &#x00BB; Soup</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Soup</span></code></h1><p>Easy functional HTML scraping and manipulation.</p><p>Lambda Soup is an HTML data extraction and analysis library. It supports CSS selectors, DOM traversals, mutation, and HTML output. This very documentation page was generated by <code>ocamldoc</code> and then <a href="https://github.com/aantron/lambdasoup/blob/master/docs/postprocess.ml">rewritten</a> by Lambda Soup!</p><p>Here are some usage examples:</p><pre class="language-ocaml"><code>open Soup

let soup = read_channel stdin |&gt; parse in

(* Print the page title. *)
soup $ &quot;title&quot; |&gt; R.leaf_text |&gt; print_endline;

(* Print the targets of all links. *)
soup $$ &quot;a[href]&quot;
|&gt; iter (fun a -&gt; print_endline (R.attribute &quot;href&quot; a));

(* Find the first unordered list. *)
let ul = soup $ &quot;ul&quot; in

(* Print the contents of all its items. *)
ul $$ &quot;li&quot;
|&gt; iter (fun li -&gt;
  trimmed_texts li |&gt; String.concat &quot;&quot; |&gt; print_endline)

(* Find all subsequent sibling elements of the same list. *)
let _ = ul $$ &quot;~ *&quot; in

(* Find all previous sibling elements instead. *)
let _ = ul |&gt; previous_siblings |&gt; elements in

(* ... *)</code></pre><p>Lambda Soup is based around two kind of values: <em>nodes</em>, which represent HTML elements, text content, and so on, and <em>traversals</em>, which are lazy sequences of nodes. The top-level node is the <em>soup node</em> (a.k.a. document node), which you typically get by calling <a href="#val-parse"><code>parse</code></a> on a string containing HTML.</p><p>Once you have a node, you call <a href="#val-select"><code>select</code></a> on it to traverse to other nodes using CSS. There are also specialized functions, such as <a href="#val-ancestors"><code>ancestors</code></a> and <a href="#val-previous_siblings"><code>previous_siblings</code></a>, which allow you to traverse in directions that CSS cannot express.</p><p>Traversals can be manipulated with familiar combinators such as <a href="#val-map"><code>map</code></a>, <a href="#val-fold"><code>fold</code></a>, and <a href="#val-filter"><code>filter</code></a>. They can also be terminated early.</p><p>Once you have traversed to a node you are interested in, you can extract its content or attributes, mutate it, cause other side effects, begin another traversal, or do anything else your application requires. Enjoy!</p><p>Lambda Soup is developed on <a href="https://github.com/aantron/lambdasoup">GitHub</a> and distributed under the <a href="https://github.com/aantron/lambdasoup/blob/master/LICENSE.md">BSD license</a>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#types">Types</a></li><li><a href="#high-level-interface">High-level interface</a></li><li><a href="#options">Options</a></li><li><a href="#early-termination">Early termination</a></li><li><a href="#element-access">Element access</a></li><li><a href="#content-access">Content access</a></li><li><a href="#elementary-traversals">Elementary traversals</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#projection">Projection</a></li><li><a href="#convenience">Convenience</a></li><li><a href="#printing">Printing</a></li><li><a href="#parsing-signals">Parsing signals</a></li><li><a href="#equality">Equality</a></li><li><a href="#mutation">Mutation</a></li><li><a href="#i/o">I/O</a></li></ul></nav></div><div class="odoc-content"><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type anchored" id="type-element"><a href="#type-element" class="anchor"></a><code><span><span class="keyword">type</span> element</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-general"><a href="#type-general" class="anchor"></a><code><span><span class="keyword">type</span> general</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-soup"><a href="#type-soup" class="anchor"></a><code><span><span class="keyword">type</span> soup</span></code></div><div class="spec-doc"><p>&quot;Phantom&quot; types for use with <code>'a node</code>. See explanation below.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a node</span></span></code></div><div class="spec-doc"><p>HTML nodes. These come in three varieties: <code>element node</code> represents a node that is known to be an element, <code>soup node</code> represents an entire document, and <code>general node</code> represents a node that might be anything, including an element, a document, or text. There is no phantom type specifically for text nodes.</p><p>Throughout Lambda Soup, if a function can operate on any kind of node, the argument is typed at <code>'a node</code>. If an element node or the entire document is required, the argument type is <code>element node</code> or <code>soup node</code>, respectively. <code>general node</code> is the result of a function that can't guarantee that it evaluates to only elements or only documents.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-nodes"><a href="#type-nodes" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a nodes</span></span></code></div><div class="spec-doc"><p>Sequence of nodes. This is always instantiated as either <code>element nodes</code> or or <code>general nodes</code>. The sequence is <em>lazy</em> in the sense that only as many elements as needed are evaluated. This can be used with <a href="#val-with_stop"><code>with_stop</code></a> to traverse part of a document until some condition is met.</p></div></div><h3 id="high-level-interface"><a href="#high-level-interface" class="anchor"></a>High-level interface</h3><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-soup">soup</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Parses the given HTML and produces a document node. Entity references are resolved. The character encoding is detected automatically.</p><p>If you need to parse XML, want finer control over parsing, or want to feed Lambda Soup something other than bytes, see <a href="#2_Parsingsignals">Parsing signals</a>.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Parse_error"><a href="#exception-Parse_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Parse_error</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Raised when a CSS selector given to <a href="#val-select"><code>select</code></a> and similar functions is syntactically invalid.</p><p>Note that <a href="#val-parse"><code>parse</code></a> does not raise this exception, because the parsing of HTML is done by <a href="https://github.com/aantron/markup.ml">Markup.ml</a>. Lambda Soup proper only parses CSS selectors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select"><a href="#val-select" class="anchor"></a><code><span><span class="keyword">val</span> select : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-element">element</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>select selector node</code> is all the descendants of <code>node</code> matching CSS selector <code>selector</code>. All <a href="http://www.w3.org/TR/selectors/#selectors">CSS3 selectors</a> are supported, except those which imply layout or a user interface:</p><pre class="language-ocaml"><code>:link, :visited, :hover, :active, :focus, :target, :lang, :enabled,
:disabled, :checked, :indeterminate, ::first-line, ::first-letter,
::selection, ::before, ::after</code></pre><p>XML namespace selectors are not supported. Lambda Soup supports the canceled <a href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/#content-selectors"><code>:contains(&quot;foo&quot;)</code></a> pseudo-class.</p><p>In regular CSS, a selector cannot start with a combinator such as <code>&gt;</code>. Lambda Soup allows selectors such as <code>&gt; p</code>, <code>+ p</code>, and <code>~ p</code>, which select immediate children of <code>node</code>, adjacent next siblings, and all next siblings, respectively.</p><p>In addition, you can use the empty selector to select <code>node</code> itself. In this case, note that if <code>node</code> is not an element (for example, it is often the soup node), <code>select</code> will result in nothing: <code>select</code> always results in sequences of <em>element</em> nodes only.</p><p><a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">CSS escape sequences</a> are supported in identifiers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select_one"><a href="#val-select_one" class="anchor"></a><code><span><span class="keyword">val</span> select_one : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Like <code>select</code>, but evaluates to at most one element. Note that there is also <code>R.select_one</code> if you don't want an optional result, which is explained at <a href="#val-require"><code>require</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-($$)"><a href="#val-($$)" class="anchor"></a><code><span><span class="keyword">val</span> ($$) : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-element">element</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>node $$ selector</code> is the same as <code>select selector node</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-($?)"><a href="#val-($?)" class="anchor"></a><code><span><span class="keyword">val</span> ($?) : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p><code>node $? selector</code> is the same as <code>select_one selector node</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span><span class="keyword">val</span> ($) : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-element">element</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p><code>node $ selector</code> is the same as <code>select_one selector node |&gt; require</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Open <code>Soup.Infix</code> instead of <code>Soup</code> to introduce only the infix operators <code>$$</code>, <code>$?</code>, and <code>$</code> into your scope.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matches_selector"><a href="#val-matches_selector" class="anchor"></a><code><span><span class="keyword">val</span> matches_selector : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>matches_select selector root node</code> checks if <code>node</code> would match <code>selector</code> in the <code>root_node</code> document.</p><p><code>node</code> <em>should</em> be a child of the <code>root_node</code>. If <code>node</code> is a standalone element node created with <a href="#val-create_element"><code>create_element</code></a> or a child of some other root node, the result will always be <code>false</code>.</p></div></div><h3 id="options"><a href="#options" class="anchor"></a>Options</h3><div class="odoc-spec"><div class="spec value anchored" id="val-require"><a href="#val-require" class="anchor"></a><code><span><span class="keyword">val</span> require : <span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>require (Some v)</code> evaluates to <code>v</code>, and <code>require None</code> raises <code>Failure</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-R"><a href="#module-R" class="anchor"></a><code><span><span class="keyword">module</span> <a href="R/index.html">R</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>For each function <code>Soup.f</code> that evaluates to an option, <code>Soup.R.f</code> is a version of <code>f</code> that is post-composed with <a href="#val-require"><code>require</code></a>, so, for example, you can write <code>soup |&gt; children |&gt; R.first</code> instead of <code>soup |&gt; children |&gt; first |&gt; require</code>.</p></div></div><h3 id="early-termination"><a href="#early-termination" class="anchor"></a>Early termination</h3><div class="odoc-spec"><div class="spec type anchored" id="type-stop"><a href="#type-stop" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a stop</span></span><span> = </span><span>{</span></code><ol><li id="type-stop.throw" class="def record field anchored"><a href="#type-stop.throw" class="anchor"></a><code><span>throw : 'b. <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Used for early termination. See <a href="#val-with_stop"><code>with_stop</code></a> below.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_stop"><a href="#val-with_stop" class="anchor"></a><code><span><span class="keyword">val</span> with_stop : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-stop">stop</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_stop (fun stop -&gt; e)</code> behaves as <code>e</code>. However, if the evaluation of <code>e</code> calls <code>stop.throw v</code>, the whole expression immediately evaluates to <code>v</code> instead.</p><p>For example, here is an expression that finds the first node with a <code>draggable</code> attribute, stopping traversal immediately when that occurs:</p><pre class="language-ocaml"><code>with_stop (fun stop -&gt;
  some_root_node
  |&gt; descendants
  |&gt; elements
  |&gt; iter (fun element -&gt;
    if has_attribute &quot;draggable&quot; element then
      stop.throw (Some element));
  None)</code></pre></div></div><h3 id="element-access"><a href="#element-access" class="anchor"></a>Element access</h3><div class="odoc-spec"><div class="spec value anchored" id="val-name"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>The element's tag name. For example, an <code>&lt;a&gt;</code> element has tag name <code>a</code>. All tag names are converted to lowercase.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-attribute"><a href="#val-attribute" class="anchor"></a><code><span><span class="keyword">val</span> attribute : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>attribute attr element</code> retrieves the value of attribute <code>attr</code> from the given element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-classes"><a href="#val-classes" class="anchor"></a><code><span><span class="keyword">val</span> classes : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>The element's class list. For example, <code>&lt;a class=&quot;foo bar&quot;&gt;</code> has class list <code>[&quot;foo&quot;; &quot;bar&quot;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-id"><a href="#val-id" class="anchor"></a><code><span><span class="keyword">val</span> id : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p>The element's id.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_attribute"><a href="#val-has_attribute" class="anchor"></a><code><span><span class="keyword">val</span> has_attribute : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_attribute attr element</code> indicates whether <code>element</code> has attribute <code>attr</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_attributes"><a href="#val-fold_attributes" class="anchor"></a><code><span><span class="keyword">val</span> fold_attributes : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_attributes f init element</code> applies <code>f</code> successively to the names and values of the attributes of <code>element</code>. The first <code>string</code> argument to <code>f</code> is the attribute name, and the second is the value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-coerce"><a href="#val-coerce" class="anchor"></a><code><span><span class="keyword">val</span> coerce : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p><code>coerce node</code> evaluates to <code>node</code>, but with type <code>general node</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-element"><a href="#val-element" class="anchor"></a><code><span><span class="keyword">val</span> element : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Given any node, asserts that it is an element <code>e</code>. If so, evaluates to <code>Some e</code>. Otherwise, evaluates to <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span><span class="keyword">val</span> elements : <span><span><span class="type-var">_</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-element">element</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p>Filters non-elements from a sequence of nodes.</p></div></div><h3 id="content-access"><a href="#content-access" class="anchor"></a>Content access</h3><div class="odoc-spec"><div class="spec value anchored" id="val-texts"><a href="#val-texts" class="anchor"></a><code><span><span class="keyword">val</span> texts : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>texts node</code> is the content of all text nodes that are descendants of <code>node</code>. If <code>node</code> is itself a text node, evaluates to <code>node</code>'s content.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trimmed_texts"><a href="#val-trimmed_texts" class="anchor"></a><code><span><span class="keyword">val</span> trimmed_texts : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-texts"><code>texts</code></a>, but all strings are passed through <code>String.trim</code>, and then all empty strings are filtered out.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-leaf_text"><a href="#val-leaf_text" class="anchor"></a><code><span><span class="keyword">val</span> leaf_text : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>leaf_text node</code> retrieves the content of one text node in <code>node</code>:</p><ul><li>If <code>node</code> is a text node itself, with value <code>s</code>, <code>leaf_text node</code> evaluates to <code>Some s</code>.</li><li>If <code>node</code> is an element or soup node, then, <code>leaf_text node</code> filters out all text children of <code>node</code> containing only whitespace. If there is only one child <code>child</code> remaining, it evaluates to <code>leaf_text child</code>. If there are no children remaining, it evaluates to <code>Some &quot;&quot;</code>. If there are two or more children remaining, it evaluates to <code>None</code>.</li></ul><p>Here are some examples of what <code>leaf_text</code> produces for various nodes:</p><pre class="language-ocaml"><code>some text                                =&gt;   Some &quot;some text&quot;
&lt;p&gt;some text&lt;/p&gt;                         =&gt;   Some &quot;some text&quot;
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;              =&gt;   Some &quot;some text&quot;
&lt;div&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;             =&gt;   Some &quot;some text&quot;
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;p&gt;more&lt;/p&gt;&lt;/div&gt;   =&gt;   None
&lt;div&gt;&lt;/div&gt;                              =&gt;   Some &quot;&quot;</code></pre></div></div><h3 id="elementary-traversals"><a href="#elementary-traversals" class="anchor"></a>Elementary traversals</h3><div class="odoc-spec"><div class="spec value anchored" id="val-children"><a href="#val-children" class="anchor"></a><code><span><span class="keyword">val</span> children : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>children node</code> is the sequence of all children of <code>node</code>. If <code>node</code> is a text node, the traversal is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-descendants"><a href="#val-descendants" class="anchor"></a><code><span><span class="keyword">val</span> descendants : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>descendants node</code> is the sequence of all descendants of <code>node</code>. <code>node</code> is not considered to be its own descendant. If <code>node</code> is a text node, the traversal is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ancestors"><a href="#val-ancestors" class="anchor"></a><code><span><span class="keyword">val</span> ancestors : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-element">element</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>ancestors node</code> is the sequence of all ancestors of <code>node</code>. <code>node</code> is not considered to be its own ancestor. The soup node is not included. Ancestors are ordered by proximity to <code>node</code>, i.e. the sequence goes up the DOM tree to a root element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-siblings"><a href="#val-siblings" class="anchor"></a><code><span><span class="keyword">val</span> siblings : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>siblings node</code> is the sequence of all siblings of <code>node</code>. <code>node</code> is not considered to be its own sibling. The siblings are ordered as they appear in the child list of <code>node</code>'s parent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next_siblings"><a href="#val-next_siblings" class="anchor"></a><code><span><span class="keyword">val</span> next_siblings : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-siblings"><code>siblings</code></a>, but only those siblings which follow <code>node</code> in its parent's child list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-previous_siblings"><a href="#val-previous_siblings" class="anchor"></a><code><span><span class="keyword">val</span> previous_siblings : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-siblings"><code>siblings</code></a>, but only those siblings which precede <code>node</code> in its parent's child list, and ordered by proximity to <code>node</code>, i.e. the reverse order of appearance in <code>node</code>'s parent's child list.</p></div></div><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold f init s</code> folds <code>f</code> over the nodes of <code>s</code>, i.e. if <code>s</code> is <code>n, n', n'', ...</code>, evaluates <code>f (f (f init n) n') n'' ...</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>filter f s</code> is the sequence consisting of the nodes <code>n</code> of <code>s</code> for which <code>f n</code> evaluates to <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-node">node</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>map f s</code> is the sequence consisting of nodes <code>f n</code> for each node <code>n</code> of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-node">node</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f s</code> is the sequence consisting of nodes <code>n'</code> for each node <code>n</code> of <code>s</code> for which <code>f n</code> evaluates to <code>Some n'</code>. Nodes for which <code>f n</code> evaluates to <code>None</code> are dropped.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-nodes">nodes</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p><code>flatten f s</code> is the sequence consisting of the concatenation of all the sequences <code>f n</code> for each <code>n</code> in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f s</code> applies <code>f</code> to each node in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p>Reverses the given node sequence. Note that this forces traversal of the sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> list</span></span></code></div><div class="spec-doc"><p>Converts the given node sequence to a list.</p></div></div><h3 id="projection"><a href="#projection" class="anchor"></a>Projection</h3><div class="odoc-spec"><div class="spec value anchored" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p><code>nth n s</code> evaluates to the <code>n</code>th member of <code>s</code>, if it is present. The index is 1-based. This is for consistency with the CSS <code>:nth-child</code> selectors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Evaluates to the first node of the given sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Evaluates the entire given sequence and returns the last node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-count"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><span><span class="type-var">'a</span> <a href="#type-nodes">nodes</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Evaluates the entire given sequence and then returns the number of nodes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span><span class="keyword">val</span> index_of : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Evaluates to the index of the given node in its parent's child list. If the node has no parent, the index is 1. The index is 1-based, according to CSS convention.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index_of_element"><a href="#val-index_of_element" class="anchor"></a><code><span><span class="keyword">val</span> index_of_element : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Evaluates to the element index of the given element in the parent's child list. That is, the index of the given element when the parent's non-element children are disregarded. The index is 1-based, according to CSS convention.</p></div></div><h3 id="convenience"><a href="#convenience" class="anchor"></a>Convenience</h3><div class="odoc-spec"><div class="spec value anchored" id="val-tags"><a href="#val-tags" class="anchor"></a><code><span><span class="keyword">val</span> tags : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-element">element</a> <a href="#type-nodes">nodes</a></span></span></code></div><div class="spec-doc"><p>Evaluates to all descendant elements of the given node that have the given tag name. For example, <code>some_root_node |&gt; tags &quot;a&quot;</code> is a sequence of all <code>a</code> elements under <code>some_root_node</code>. It is equivalent to</p><pre class="language-ocaml"><code>some_root_node
|&gt; descendants |&gt; elements |&gt; filter (fun e -&gt; name e = &quot;a&quot;)</code></pre><p>and</p><pre class="language-ocaml"><code>some_root_node $$ &quot;a&quot;</code></pre><p>Tag names are case-insensitive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tag"><a href="#val-tag" class="anchor"></a><code><span><span class="keyword">val</span> tag : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-tags"><code>tags</code></a>, but evaluates to only the first element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parent"><a href="#val-parent" class="anchor"></a><code><span><span class="keyword">val</span> parent : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Given a node, evaluates to its parent element, if it has one. Note that root nodes do not have a parent <em>element</em>, as their parent is the soup node. Equivalent to <code>n |&gt; ancestors |&gt; first</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_root"><a href="#val-is_root" class="anchor"></a><code><span><span class="keyword">val</span> is_root : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given node is not a soup node, and either has no parent, or its parent is a soup node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_document"><a href="#val-is_document" class="anchor"></a><code><span><span class="keyword">val</span> is_document : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given node is a soup (document) node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_element"><a href="#val-is_element" class="anchor"></a><code><span><span class="keyword">val</span> is_element : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given node is an element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_text"><a href="#val-is_text" class="anchor"></a><code><span><span class="keyword">val</span> is_text : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given node is a text node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-child"><a href="#val-child" class="anchor"></a><code><span><span class="keyword">val</span> child : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-general">general</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p><code>child node</code> evaluates to <code>node</code>'s first child. Equivalent to <code>node |&gt; children |&gt; first</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-child_element"><a href="#val-child_element" class="anchor"></a><code><span><span class="keyword">val</span> child_element : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p><code>child_element node</code> evaluates to <code>node</code>'s first child element. Equivalent to <code>node |&gt; children |&gt; elements |&gt; first</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next_sibling"><a href="#val-next_sibling" class="anchor"></a><code><span><span class="keyword">val</span> next_sibling : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-general">general</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p><code>next_sibling node</code> is the next sibling of <code>node</code> in <code>node</code>'s parent's child list. Equivalent to <code>node |&gt; next_siblings |&gt; first</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-previous_sibling"><a href="#val-previous_sibling" class="anchor"></a><code><span><span class="keyword">val</span> previous_sibling : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-general">general</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-next_sibling"><code>next_sibling</code></a>, but for the preceding sibling instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next_element"><a href="#val-next_element" class="anchor"></a><code><span><span class="keyword">val</span> next_element : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p><code>next_element node</code> is the next sibling of <code>node</code> that is an element. Equivalent to <code>n |&gt; next_siblings |&gt; elements |&gt; first</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-previous_element"><a href="#val-previous_element" class="anchor"></a><code><span><span class="keyword">val</span> previous_element : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> option</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-next_element"><code>next_element</code></a>, but for the preceding siblings instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_children"><a href="#val-no_children" class="anchor"></a><code><span><span class="keyword">val</span> no_children : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given node has no child nodes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-at_most_one_child"><a href="#val-at_most_one_child" class="anchor"></a><code><span><span class="keyword">val</span> at_most_one_child : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given node has at most one child node.</p></div></div><h3 id="printing"><a href="#printing" class="anchor"></a>Printing</h3><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Converts the node tree rooted at the given node to an HTML5 string, preserving whitespace nodes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span><span class="keyword">val</span> pretty_print : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Converts the node tree rooted at the given node to an HTML5 string formatted for easy reading by humans, difference algorthims, etc.</p><p>Note that this can change the whitespace structure of the HTML, so it may display differently in a browser than the original parsed document.</p></div></div><h3 id="parsing-signals"><a href="#parsing-signals" class="anchor"></a>Parsing signals</h3><p>Lambda Soup uses <a href="https://github.com/aantron/markup.ml">Markup.ml</a> internally to parse and write markup. If you wish to:</p><ul><li>scrape HTML output of some process without first writing it to a string,</li><li>scrape XML,</li><li>have fine control over how parsing is done, such as encoding selection, or</li><li>run the input or output of Lambda Soup through streaming filters,</li></ul><p>then you should use the functions below instead of <a href="#val-parse"><code>parse</code></a> and <a href="#val-to_string"><code>to_string</code></a>.</p><p>See the <a href="http://aantron.github.io/markup.ml/">Markup.ml documentation</a> for a description of the types involved. The <a href="https://github.com/aantron/markup.ml#overview-and-basic-usage">Markup.ml overview</a> may be a good place to start.</p><div class="odoc-spec"><div class="spec value anchored" id="val-signals"><a href="#val-signals" class="anchor"></a><code><span><span class="keyword">val</span> signals : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../markup/Markup/index.html#type-signal">Markup.signal</a>, <a href="../../markup/Markup/index.html#type-sync">Markup.sync</a>)</span> <a href="../../markup/Markup/index.html#type-stream">Markup.stream</a></span></span></code></div><div class="spec-doc"><p>Converts the node tree rooted at the given node to a stream of Markup.ml signals. This underlies <a href="#val-to_string"><code>to_string</code></a> and <a href="#val-pretty_print"><code>pretty_print</code></a>.</p><p>For example, you can use this function together with <a href="http://aantron.github.io/markup.ml/#VALwrite_xml"><code>Markup.write_xml</code></a> to output XML, instead of HTML:</p><pre class="language-ocaml"><code>soup |&gt; signals |&gt; Markup.write_xml |&gt; Markup.to_string</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_signals"><a href="#val-from_signals" class="anchor"></a><code><span><span class="keyword">val</span> from_signals : <span><span><span>(<a href="../../markup/Markup/index.html#type-signal">Markup.signal</a>, <a href="../../markup/Markup/index.html#type-sync">Markup.sync</a>)</span> <a href="../../markup/Markup/index.html#type-stream">Markup.stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-soup">soup</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Converts a stream of Markup.ml signals to a Lambda Soup document. This underlies <a href="#val-parse"><code>parse</code></a>.</p><p>For example, you can use this function together with <a href="http://aantron.github.io/markup.ml/#VALparse_xml"><code>Markup.parse_xml</code></a> to load XML into Lambda Soup:</p><pre class="language-ocaml"><code>Markup.string s |&gt; Markup.parse_xml |&gt; Markup.signals |&gt; from_signals</code></pre><p>Namespaces are ignored at the moment.</p></div></div><h3 id="equality"><a href="#equality" class="anchor"></a>Equality</h3><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal n n'</code> recursively tests the node trees rooted at <code>n</code> and <code>n'</code> for equality. To test <code>true</code>, the trees must be identical, including whitespace text nodes. Class attributes and other multi-valued attributes are compared literally: classes must be listed in the same order, with the same amount of whitespace in the attribute value. For the purposes of comparison, adjacent text nodes are merged, and empty text nodes are ignored: this is the standard HTML normalization procedure.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_modulo_whitespace"><a href="#val-equal_modulo_whitespace" class="anchor"></a><code><span><span class="keyword">val</span> equal_modulo_whitespace : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal_modulo_whitespace n n'</code> is like <code>equal n n'</code>, but all text nodes have their values passed through <code>String.trim</code>. Text nodes that become empty are then ignored for the purpose of comparison, as in <code>equal</code>.</p></div></div><h3 id="mutation"><a href="#mutation" class="anchor"></a>Mutation</h3><div class="odoc-spec"><div class="spec value anchored" id="val-create_element"><a href="#val-create_element" class="anchor"></a><code><span><span class="keyword">val</span> create_element : 
  <span><span class="optlabel">?id</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?class_</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?classes</span>:<span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?attributes</span>:<span><span>(string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?inner_text</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-element">element</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p><code>create_element tag</code> creates a new element with the name <code>tag</code>.</p><p>If <code>~attributes</code> is specified, the given attributes are added to the element. <code>~attributes</code> defaults to <code>[]</code>.</p><p>If <code>~classes</code> is specified, the class names are concatenated into a single string <code>s</code> and the <code>class</code> attribute is set on the element to the resulting value. This takes precedence over <code>~attributes</code>.</p><p>If <code>~class</code> is specified, the class is set on the element. This takes precedence over both <code>~attributes</code> and <code>~classes</code>.</p><p>If <code>~id</code> is specified, the id is set. This takes precedence over <code>~attributes</code>.</p><p>If <code>~inner_text</code> is specified, a text node is created with the given string, and made the single child of the new element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_text"><a href="#val-create_text" class="anchor"></a><code><span><span class="keyword">val</span> create_text : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-general">general</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Creates a new text node with the given content.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_soup"><a href="#val-create_soup" class="anchor"></a><code><span><span class="keyword">val</span> create_soup : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-soup">soup</a> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Creates a new empty document node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append_child"><a href="#val-append_child" class="anchor"></a><code><span><span class="keyword">val</span> append_child : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>append_child element node</code> adds <code>node</code> to the end of the child list of <code>element</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prepend_child"><a href="#val-prepend_child" class="anchor"></a><code><span><span class="keyword">val</span> prepend_child : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>prepend_child element node</code> adds <code>node</code> to the beginning of the child list of <code>element</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert_at_index"><a href="#val-insert_at_index" class="anchor"></a><code><span><span class="keyword">val</span> insert_at_index : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>insert_at_index k element node</code> makes <code>node</code> the <code>k</code>th child of <code>element</code>. Note that the index is 1-based. If <code>k</code> is outside the range of current valid indices, <code>node</code> is inserted at the beginning or end of <code>element</code>'s child list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert_before"><a href="#val-insert_before" class="anchor"></a><code><span><span class="keyword">val</span> insert_before : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>insert_before node node'</code> inserts <code>node'</code> immediately before <code>node</code> in <code>node</code>'s parent's child list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert_after"><a href="#val-insert_after" class="anchor"></a><code><span><span class="keyword">val</span> insert_after : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>insert_after node node'</code> inserts <code>node'</code> immediately after <code>node</code> in <code>node</code>'s parent's child list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span><span class="keyword">val</span> delete : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Deletes the given node by unlinking it from its parent. If the node has descendants, they are implicitly deleted by this operation as well, in the sense that they become unreachable from the parent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Unlinks all children of the given node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span><span class="keyword">val</span> replace : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>replace target other</code> mutably replaces <code>target</code> with <code>other</code>. <code>target</code> and <code>other</code> are both deleted from their respective document trees. Then, <code>other</code> is inserted where <code>target</code> used to be in its document tree.</p><p>Note that you cannot replace multiple targets with <code>other</code>: <code>replace</code> will work as expected for the first target, but for the second target, it will <em>remove</em> <code>other</code> from where the first target was, and insert it where the second target is. To replace multiple targets, you need multiple copies of <code>other</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span><span class="keyword">val</span> swap : <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>swap element element'</code> replaces <code>element</code> with <code>element'</code> in <code>element</code>'s parent's child list. All children of <code>element</code> are transferred to <code>element'</code>, and all original children of <code>element'</code> are transferred to <code>element</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrap"><a href="#val-wrap" class="anchor"></a><code><span><span class="keyword">val</span> wrap : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>wrap node element</code> inserts <code>element</code> in the place of <code>node</code>, and then makes <code>node</code> <code>element</code>'s child. All original children of <code>element</code> are unlinked.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unwrap"><a href="#val-unwrap" class="anchor"></a><code><span><span class="keyword">val</span> unwrap : <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unwrap node</code> unlinks <code>node</code>, and inserts all of <code>node</code>'s children as children of <code>node</code>'s parent at the former location of <code>node</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append_root"><a href="#val-append_root" class="anchor"></a><code><span><span class="keyword">val</span> append_root : <span><span><a href="#type-soup">soup</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>append_root soup node</code> adds <code>node</code> as the last root node of <code>soup</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prepend_root"><a href="#val-prepend_root" class="anchor"></a><code><span><span class="keyword">val</span> prepend_root : <span><span><a href="#type-soup">soup</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>prepend_root soup node</code> adds <code>node</code> as the first root node of <code>soup</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_name"><a href="#val-set_name" class="anchor"></a><code><span><span class="keyword">val</span> set_name : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Sets the tag name of the given element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_attribute"><a href="#val-set_attribute" class="anchor"></a><code><span><span class="keyword">val</span> set_attribute : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_attribute attr value element</code> sets the value of attribute <code>attr</code> on <code>element</code> to <code>value</code>. If the attribute is not present, it is added to <code>element</code>. If it is already present, the value is replaced.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delete_attribute"><a href="#val-delete_attribute" class="anchor"></a><code><span><span class="keyword">val</span> delete_attribute : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Removes the given attribute from the given element. If the attribute is not present, has no effect.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_class"><a href="#val-add_class" class="anchor"></a><code><span><span class="keyword">val</span> add_class : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_class c element</code> adds class <code>c</code> to <code>element</code>, if <code>element</code> does not already have class <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_class"><a href="#val-remove_class" class="anchor"></a><code><span><span class="keyword">val</span> remove_class : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-element">element</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_class c element</code> removes class <code>c</code> from <code>element</code>, if <code>element</code> has class <code>c</code>.</p></div></div><h3 id="i/o"><a href="#i/o" class="anchor"></a>I/O</h3><p>Lambda Soup is not an I/O library. However, it provides a few simple helpers based on standard I/O functions in <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#6_Inputoutput"><code>Pervasives</code></a>. These should not be used for &quot;serious&quot; code. They are only for when you need to get something done quickly, and/or don't care about corner cases, concurrency, or excellent reliability. In such cases, they allow you to avoid writing I/O wrappers or using additional libraries.</p><p>Using these, you can write little command-line scrapers and filters:</p><pre class="language-ocaml"><code>let () =
  let soup = read_channel stdin |&gt; parse in
  let () = (* ...do things to soup... *) in
  soup |&gt; to_string |&gt; write_channel stdout</code></pre><p>If the above is compiled to a file <code>scrape</code>, you can then run</p><pre class="language-ocaml"><code>curl -L &quot;http://location.com&quot; | ./scrape</code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-read_file"><a href="#val-read_file" class="anchor"></a><code><span><span class="keyword">val</span> read_file : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Reads the entire contents of the file with the given path. Raises <code>Sys_error</code> on failure.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_channel"><a href="#val-read_channel" class="anchor"></a><code><span><span class="keyword">val</span> read_channel : <span><a href="../../../stdlib/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Reads all bytes from the given channel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_file"><a href="#val-write_file" class="anchor"></a><code><span><span class="keyword">val</span> write_file : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_file path data</code> writes <code>data</code> to the file given by <code>path</code>. If the file already exists, it is truncated (erased). If you want to append to file, use <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALopen_out_gen"><code>open_out_gen</code></a> with the necessary flags, and pass the resulting channel to <code>write_channel</code>. Raises <code>Sys_error</code> on failure.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_channel"><a href="#val-write_channel" class="anchor"></a><code><span><span class="keyword">val</span> write_channel : <span><a href="../../../stdlib/Stdlib/index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Writes the given data to the given channel.</p></div></div></div></body></html>
