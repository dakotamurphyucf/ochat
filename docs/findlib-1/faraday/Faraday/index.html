<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Faraday (docs.findlib-1.faraday.Faraday)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../';
let search_urls = ['../../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">findlib-1</a> &#x00BB; <a href="../index.html">faraday</a> &#x00BB; Faraday</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Faraday</span></code></h1><p>Serialization primitives built for speed an memory-efficiency.</p><p>Faraday is a library for writing fast and memory-efficient serializers. Its core type and related operation gives the user fine-grained control over copying and allocation behavior while serializing user-defined types, and presents the output in a form that makes it possible to use vectorized write operations, such as the <code>writev</code> system call, or any other platform or application-specific output APIs.</p><p>A Faraday serializer manages an internal buffer and a queue of output buffers. The output bufferes may be a sub range of the serializer's internal buffer or one that is user-provided. Buffered writes such as <a href="#val-write_string"><code>write_string</code></a>, <a href="#val-write_char"><code>write_char</code></a>, <a href="#val-write_bigstring"><code>write_bigstring</code></a>, etc., copy the source bytes into the serializer's internal buffer. Unbuffered writes such as <code>schedule_string</code>, <a href="#val-schedule_bigstring"><code>schedule_bigstring</code></a>, etc., on the other hand perform no copying. Instead, they enqueue the source bytes into the serializer's write queue directly.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#buffered-writes">Buffered Writes</a></li><li><a href="#unbuffered-writes">Unbuffered Writes</a></li><li><a href="#querying-a-serializer's-state">Querying A Serializer's State</a></li><li><a href="#control-operations">Control Operations</a></li><li><a href="#running">Running</a></li><li><a href="#convenience-functions">Convenience Functions</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-bigstring"><a href="#type-bigstring" class="anchor"></a><code><span><span class="keyword">type</span> bigstring</span><span> =
  <span><span>(char, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../stdlib/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../../stdlib/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of a serializer.</p></div></div><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create len</code> creates a serializer with a fixed-length internal buffer of length <code>len</code>. See the Buffered writes section for details about what happens when <code>len</code> is not large enough to support a write.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bigstring"><a href="#val-of_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> of_bigstring : <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bigstring buf</code> creates a serializer, using <code>buf</code> as its internal buffer. The serializer takes ownership of <code>buf</code> until the serializer has been closed and flushed of all output.</p></div></div><h3 id="buffered-writes"><a href="#buffered-writes" class="anchor"></a>Buffered Writes</h3><p>A serializer manages an internal buffer for coalescing small writes. The size of this buffer is determined when the serializer is created. If the buffer does not contain sufficient space to service a caller's buffered write, the serializer will allocate a new buffer of the sufficient size and use it for the current and subsequent writes. The old buffer will be garbage collected once all of its contents have been <a href="#val-flush"><code>flush</code></a>ed.</p><div class="odoc-spec"><div class="spec value anchored" id="val-write_string"><a href="#val-write_string" class="anchor"></a><code><span><span class="keyword">val</span> write_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_string t ?off ?len str</code> copies <code>str</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span><span class="keyword">val</span> write_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../stdlib/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_bytes t ?off ?len bytes</code> copies <code>bytes</code> into the serializer's internal buffer. It is safe to modify <code>bytes</code> after this call returns.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_bigstring"><a href="#val-write_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> write_bigstring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_bigstring t ?off ?len bigstring</code> copies <code>bigstring</code> into the serializer's internal buffer. It is safe to modify <code>bigstring</code> after this call returns.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_gen"><a href="#val-write_gen" class="anchor"></a><code><span><span class="keyword">val</span> write_gen : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">length</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">blit</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">src_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">dst_off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>write_gen t ~length ~blit ?off ?len x</code> copies <code>x</code> into the serializer's internal buffer using the provided <code>length</code> and <code>blit</code> operations. See <code>Bigstring.blit</code> for documentation of the arguments.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_char"><a href="#val-write_char" class="anchor"></a><code><span><span class="keyword">val</span> write_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_char t char</code> copies <code>char</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_uint8"><a href="#val-write_uint8" class="anchor"></a><code><span><span class="keyword">val</span> write_uint8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_uint8 t n</code> copies the lower 8 bits of <code>n</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span><span class="keyword">module</span> <a href="BE/index.html">BE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Big endian serializers</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span><span class="keyword">module</span> <a href="LE/index.html">LE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Little endian serializers</p></div></div><h3 id="unbuffered-writes"><a href="#unbuffered-writes" class="anchor"></a>Unbuffered Writes</h3><p>Unbuffered writes do not involve copying bytes to the serializers internal buffer.</p><div class="odoc-spec"><div class="spec value anchored" id="val-schedule_bigstring"><a href="#val-schedule_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> schedule_bigstring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>schedule_bigstring t ?off ?len bigstring</code> schedules <code>bigstring</code> to be written the next time the serializer surfaces writes to the user. <code>bigstring</code> is not copied in this process, so <code>bigstring</code> should only be modified after <code>t</code> has been <a href="#val-flush"><code>flush</code></a>ed.</p></div></div><h3 id="querying-a-serializer's-state"><a href="#querying-a-serializer's-state" class="anchor"></a>Querying A Serializer's State</h3><div class="odoc-spec"><div class="spec value anchored" id="val-free_bytes_in_buffer"><a href="#val-free_bytes_in_buffer" class="anchor"></a><code><span><span class="keyword">val</span> free_bytes_in_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>free_bytes_in_buffer t</code> returns the free space, in bytes, of the serializer's write buffer. If a <code>write_*</code> call has a length that exceeds this value, the serializer will allocate a new buffer that will replace the serializer's internal buffer for that and subsequent calls.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_pending_output"><a href="#val-has_pending_output" class="anchor"></a><code><span><span class="keyword">val</span> has_pending_output : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_pending_output t</code> is <code>true</code> if <code>t</code>'s output queue is non-empty. It may be the case that <code>t</code>'s queued output is being serviced by some other thread of control, but has not yet completed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pending_bytes"><a href="#val-pending_bytes" class="anchor"></a><code><span><span class="keyword">val</span> pending_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>pending_bytes t</code> is the size of the next write, in bytes, that <code>t</code> will surface to the caller as a <code>`Writev</code>.</p></div></div><h3 id="control-operations"><a href="#control-operations" class="anchor"></a>Control Operations</h3><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield t</code> causes <code>t</code> to delay surfacing writes to the user, instead returning a <code>`Yield</code>. This gives the serializer an opportunity to collect additional writes before sending them to the underlying device, which will increase the write batch size.</p><p>As one example, code may want to call this function if it's about to release the OCaml lock and perform a blocking system call, but would like to batch output across that system call. To hint to the thread of control that is performing the writes on behalf of the serializer, the code might call <code>yield t</code> before releasing the lock.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>flush t f</code> registers <code>f</code> to be called when all prior writes have been successfully completed. If <code>t</code> has no pending writes, then <code>f</code> will be called immediately. If <a href="#val-yield"><code>yield</code></a> was recently called on <code>t</code>, then the effect of the <code>yield</code> will be ignored so that client code has an opportunity to write pending output, regardless of how it handles <code>`Yield</code> operations.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Flushed_reason"><a href="#module-Flushed_reason" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Flushed_reason/index.html">Flushed_reason</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush_with_reason"><a href="#val-flush_with_reason" class="anchor"></a><code><span><span class="keyword">val</span> flush_with_reason : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="Flushed_reason/index.html#type-t">Flushed_reason.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>flush_with_reason t f</code> is like <code>flush t f</code>, but <code>f</code> is suppplied with the reason that the callback was triggered.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> closes <code>t</code>. All subsequent write calls will raise, and any pending or subsequent <a href="#val-yield"><code>yield</code></a> calls will be ignored. If the serializer has any pending writes, user code will have an opportunity to service them before it receives the <code>Close</code> operation. Flush callbacks will continue to be invoked while output is <a href="#val-shift"><code>shift</code></a>ed out of <code>t</code> as needed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> is <code>true</code> if <code>close</code> has been called on <code>t</code> and <code>false</code> otherwise. A closed <code>t</code> may still have pending output.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span><span class="keyword">val</span> shift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>shift t n</code> removes the first <code>n</code> bytes in <code>t</code>'s write queue. Any flush callbacks registered with <code>t</code> within this span of the write queue will be called.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>drain t</code> removes all pending writes from <code>t</code>, returning the number of bytes that were enqueued to be written and freeing any scheduled buffers in the process.</p></div></div><h3 id="running"><a href="#running" class="anchor"></a>Running</h3><p>Low-level operations for runing a serializer. For production use-cases, consider the Async and Lwt support that this library includes before attempting to use this these operations directly.</p><div class="odoc-spec"><div class="spec type anchored" id="type-iovec"><a href="#type-iovec" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a iovec</span></span><span> = </span><span>{</span></code><ol><li id="type-iovec.buffer" class="def record field anchored"><a href="#type-iovec.buffer" class="anchor"></a><code><span>buffer : <span class="type-var">'a</span>;</span></code></li><li id="type-iovec.off" class="def record field anchored"><a href="#type-iovec.off" class="anchor"></a><code><span>off : int;</span></code></li><li id="type-iovec.len" class="def record field anchored"><a href="#type-iovec.len" class="anchor"></a><code><span>len : int;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A view into <a href="#type-iovec.buffer"><code>iovec.buffer</code></a> starting at <a href="#type-iovec.off"><code>iovec.off</code></a> and with length <a href="#type-iovec.len"><code>iovec.len</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-operation"><a href="#type-operation" class="anchor"></a><code><span><span class="keyword">type</span> operation</span><span> = </span><span>[ </span></code><ol><li id="type-operation.Writev" class="def variant constructor anchored"><a href="#type-operation.Writev" class="anchor"></a><code><span>| </span><span>`Writev <span class="keyword">of</span> <span><span><a href="#type-bigstring">bigstring</a> <a href="#type-iovec">iovec</a></span> list</span></span></code></li><li id="type-operation.Yield" class="def variant constructor anchored"><a href="#type-operation.Yield" class="anchor"></a><code><span>| </span><span>`Yield</span></code></li><li id="type-operation.Close" class="def variant constructor anchored"><a href="#type-operation.Close" class="anchor"></a><code><span>| </span><span>`Close</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>The type of operations that the serialier may wish to perform.</p><ul><li><code>`Writev iovecs</code>: Write the bytes in <code>iovecs</code>s reporting the actual number of bytes written by calling <a href="#val-shift"><code>shift</code></a>. You must accurately report the number of bytes written. Failure to do so will result in the same bytes being surfaced in a <code>`Writev</code> operation multiple times.</li><li><code>`Yield</code>: Yield to other threads of control, waiting for additional output before procedding. The method for achieving this is application-specific, but once complete, the caller can proceed with serialization by simply making another call to <a href="#val-operation"><code>operation</code></a> or <a href="#val-serialize"><code>serialize</code></a>.</li><li><code>`Close</code>: Serialization is complete. No further output will generated. The action to take as a result, if any, is application-specific.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-operation"><a href="#val-operation" class="anchor"></a><code><span><span class="keyword">val</span> operation : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-operation">operation</a></span></code></div><div class="spec-doc"><p><code>operation t</code> is the next operation that the caller must perform on behalf of the serializer <code>t</code>. Users should consider using <a href="#val-serialize"><code>serialize</code></a> before this function. See the documentation for the <a href="#type-operation"><code>operation</code></a> type for details on how callers should handle these operations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialize"><a href="#val-serialize" class="anchor"></a><code><span><span class="keyword">val</span> serialize : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span><a href="#type-bigstring">bigstring</a> <a href="#type-iovec">iovec</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>[ <span>`Ok of int</span> <span>| `Closed</span> ]</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>[ `Yield <span>| `Close</span> ]</span></span></code></div><div class="spec-doc"><p><code>serialize t writev</code> sufaces the next operation of <code>t</code> to the caller, handling a <code>`Writev</code> operation with <code>writev</code> function and performing an additional bookkeeping on the caller's behalf. In the event that <code>writev</code> indicates a partial write, <a href="#val-serialize"><code>serialize</code></a> will call <a href="#val-yield"><code>yield</code></a> on the serializer rather than attempting successive <code>writev</code> calls.</p></div></div><h3 id="convenience-functions"><a href="#convenience-functions" class="anchor"></a>Convenience Functions</h3><p>These functions are included for testing, debugging, and general development. They are not the suggested way of driving a serializer in a production setting.</p><div class="odoc-spec"><div class="spec value anchored" id="val-serialize_to_string"><a href="#val-serialize_to_string" class="anchor"></a><code><span><span class="keyword">val</span> serialize_to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>serialize_to_string t</code> runs <code>t</code>, collecting the output into a string and returning it. <code>serialzie_to_string t</code> immediately closes <code>t</code> and ignores any calls to <a href="#val-yield"><code>yield</code></a> on <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialize_to_bigstring"><a href="#val-serialize_to_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> serialize_to_bigstring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bigstring">bigstring</a></span></code></div><div class="spec-doc"><p><code>serialize_to_string t</code> runs <code>t</code>, collecting the output into a bigstring and returning it. <code>serialzie_to_bigstring t</code> immediately closes <code>t</code> and ignores any calls to <a href="#val-yield"><code>yield</code></a> on <code>t</code>.</p></div></div></div></body></html>
