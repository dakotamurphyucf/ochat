<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Markup (docs.findlib-1.markup.Markup)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../';
let search_urls = ['../../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">Index</a> &#x00BB; <a href="../../../index.html">docs</a> &#x00BB; <a href="../../index.html">findlib-1</a> &#x00BB; <a href="../index.html">markup</a> &#x00BB; Markup</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Markup</span></code></h1><p>Error-recovering streaming HTML and XML parsers and writers.</p><p>Markup.ml is an HTML and XML parsing and serialization library. It:</p><ul><li>Is error-recovering, so you can get a best-effort parse of malformed input.</li><li>Reports all errors before recovery, so you can get strict parsing instead.</li><li>Conforms closely to the XML grammar and HTML parser from the respective specifications.</li><li>Accepts document fragments, but can be told to accept only full documents.</li><li>Detects character encodings automatically.</li><li>Supports both simple synchronous (this module) and non-blocking usage (<code>Markup_lwt</code>).</li><li>Is streaming and lazy. Partial input is processed as soon as received, but only as needed.</li><li>Does one pass over the input and emits a stream of SAX-style parsing signals. A helper (<a href="#val-tree"><code>tree</code></a>) allows that to be easily converted into DOM-style trees.</li></ul><p>The usage is straightforward. For example:</p><pre class="language-ocaml"><code>open Markup

(* Correct and pretty-print HTML. *)
channel stdin
|&gt; parse_html |&gt; signals |&gt; pretty_print
|&gt; write_html |&gt; to_channel stdout

(* Show up to 10 XML well-formedness errors to the user. Stop after
   the 10th, without reading more input. *)
let report =
  let count = ref 0 in
  fun location error -&gt;
    error |&gt; Error.to_string ~location |&gt; prerr_endline;
    count := !count + 1;
    if !count &gt;= 10 then raise_notrace Exit

string &quot;some xml&quot; |&gt; parse_xml ~report |&gt; signals |&gt; drain

(* Load HTML into a custom document tree data type. *)
type html = Text of string | Element of string * html list

file &quot;some_file&quot;
|&gt; fst
|&gt; parse_html
|&gt; signals
|&gt; tree
  ~text:(fun ss -&gt; Text (String.concat &quot;&quot; ss))
  ~element:(fun (_, name) _ children -&gt; Element (name, children))</code></pre><p>The interface is centered around four functions. In pseudocode:</p><pre class="language-ocaml"><code>val parse_html : char stream   -&gt; signal stream
val write_html : signal stream -&gt; char stream
val parse_xml  : char stream   -&gt; signal stream
val write_xml  : signal stream -&gt; char stream</code></pre><p>Most of the remaining functions create streams from, or write streams to, strings, files, and channels, or manipulate streams, such as <a href="#val-next"><code>next</code></a> and the combinators <a href="#val-map"><code>map</code></a> and <a href="#val-fold"><code>fold</code></a>.</p><p>Apart from this module, Markup.ml provides two other top-level modules:</p><ul class="modules"><li><code>Markup_lwt</code> </li><li><code>Markup_lwt_unix</code> </li></ul><p>Most of the interface of <code>Markup_lwt</code> is specified in signature <a href="module-type-ASYNCHRONOUS/index.html"><code>ASYNCHRONOUS</code></a>, which will be shared with a <code>Markup_async</code> module, should it be implemented.</p><p>Markup.ml is developed on <a href="https://github.com/aantron/markup.ml">GitHub</a> and distributed under the <a href="https://github.com/aantron/markup.ml/blob/master/LICENSE.md">MIT license</a>. This documentation is for version 1.0.0 of the library. Documentation for older versions can be found on the <a href="https://github.com/aantron/markup.ml/releases">releases page</a>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#streams">Streams</a></li><li><a href="#errors">Errors</a></li><li><a href="#encodings">Encodings</a></li><li><a href="#signals">Signals</a></li><li><a href="#parsers">Parsers</a></li><li><a href="#xml">XML</a></li><li><a href="#html">HTML</a></li><li><a href="#input-sources">Input sources</a></li><li><a href="#output-destinations">Output destinations</a></li><li><a href="#stream-operations">Stream operations</a></li><li><a href="#utility">Utility</a></li><li><a href="#namespaces">Namespaces</a></li><li><a href="#asynchronous-interface">Asynchronous interface</a></li><li><a href="#conformance-status">Conformance status</a><ul><li><a href="#to-be-corrected:">To be corrected:</a></li><li><a href="#to-remain:">To remain:</a></li></ul></li></ul></nav></div><div class="odoc-content"><h3 id="streams"><a href="#streams" class="anchor"></a>Streams</h3><div class="odoc-spec"><div class="spec type anchored" id="type-async"><a href="#type-async" class="anchor"></a><code><span><span class="keyword">type</span> async</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-sync"><a href="#type-sync" class="anchor"></a><code><span><span class="keyword">type</span> sync</span></code></div><div class="spec-doc"><p>Phantom types for use with <code>('a, 's) stream</code> in place of <code>'s</code>. See explanation below.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 's) stream</span></span></code></div><div class="spec-doc"><p>Streams of elements of type <code>'a</code>.</p><p>In simple usage, when using only this module <code>Markup</code>, the additional type parameter <code>'s</code> is always <code>sync</code>, and there is no need to consider it further.</p><p>However, if you are using <code>Markup_lwt</code>, you may create some <code>async</code> streams. The difference between the two is that <a href="#val-next"><code>next</code></a> on a <code>sync</code> stream retrieves an element before <a href="#val-next"><code>next</code></a> &quot;returns,&quot; while <a href="#val-next"><code>next</code></a> on an <code>async</code> stream might not retrieve an element until later. As a result, it is not safe to pass an <code>async</code> stream where a <code>sync</code> stream is required. The phantom types are used to make the type checker catch such errors at compile time.</p></div></div><h3 id="errors"><a href="#errors" class="anchor"></a>Errors</h3><p>The parsers recover from errors automatically. If that is sufficient, you can ignore this section. However, if you want stricter behavior, or need to debug parser output, use optional argument <code>?report</code> of the parsers, and look in module <a href="Error/index.html"><code>Error</code></a>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-location"><a href="#type-location" class="anchor"></a><code><span><span class="keyword">type</span> location</span><span> = int * int</span></code></div><div class="spec-doc"><p>Line and column for parsing errors. Both numbers are one-based.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Error/index.html">Error</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Error type and <code>to_string</code> function.</p></div></div><h3 id="encodings"><a href="#encodings" class="anchor"></a>Encodings</h3><p>The parsers detect encodings automatically. If you need to specify an encoding, use optional argument <code>?encoding</code> of the parsers, and look in module <a href="Encoding/index.html"><code>Encoding</code></a>.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Encoding"><a href="#module-Encoding" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Encoding/index.html">Encoding</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Common Internet encodings such as UTF-8 and UTF-16; also includes some less popular encodings that are sometimes used for XML.</p></div></div><h3 id="signals"><a href="#signals" class="anchor"></a>Signals</h3><div class="odoc-spec"><div class="spec type anchored" id="type-name"><a href="#type-name" class="anchor"></a><code><span><span class="keyword">type</span> name</span><span> = string * string</span></code></div><div class="spec-doc"><p>Expanded name: a namespace URI followed by a local name.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-xml_declaration"><a href="#type-xml_declaration" class="anchor"></a><code><span><span class="keyword">type</span> xml_declaration</span><span> = </span><span>{</span></code><ol><li id="type-xml_declaration.version" class="def record field anchored"><a href="#type-xml_declaration.version" class="anchor"></a><code><span>version : string;</span></code></li><li id="type-xml_declaration.encoding" class="def record field anchored"><a href="#type-xml_declaration.encoding" class="anchor"></a><code><span>encoding : <span>string option</span>;</span></code></li><li id="type-xml_declaration.standalone" class="def record field anchored"><a href="#type-xml_declaration.standalone" class="anchor"></a><code><span>standalone : <span>bool option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Representation of an XML declaration, i.e. <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-doctype"><a href="#type-doctype" class="anchor"></a><code><span><span class="keyword">type</span> doctype</span><span> = </span><span>{</span></code><ol><li id="type-doctype.doctype_name" class="def record field anchored"><a href="#type-doctype.doctype_name" class="anchor"></a><code><span>doctype_name : <span>string option</span>;</span></code></li><li id="type-doctype.public_identifier" class="def record field anchored"><a href="#type-doctype.public_identifier" class="anchor"></a><code><span>public_identifier : <span>string option</span>;</span></code></li><li id="type-doctype.system_identifier" class="def record field anchored"><a href="#type-doctype.system_identifier" class="anchor"></a><code><span>system_identifier : <span>string option</span>;</span></code></li><li id="type-doctype.raw_text" class="def record field anchored"><a href="#type-doctype.raw_text" class="anchor"></a><code><span>raw_text : <span>string option</span>;</span></code></li><li id="type-doctype.force_quirks" class="def record field anchored"><a href="#type-doctype.force_quirks" class="anchor"></a><code><span>force_quirks : bool;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Representation of a document type declaration. The HTML parser fills in all fields besides <code>raw_text</code>. The XML parser reads declarations roughly, and fills only the <code>raw_text</code> field with the text found in the declaration.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-signal"><a href="#type-signal" class="anchor"></a><code><span><span class="keyword">type</span> signal</span><span> = </span><span>[ </span></code><ol><li id="type-signal.Start_element" class="def variant constructor anchored"><a href="#type-signal.Start_element" class="anchor"></a><code><span>| </span><span>`Start_element <span class="keyword">of</span> <a href="#type-name">name</a> * <span><span>(<a href="#type-name">name</a> * string)</span> list</span></span></code></li><li id="type-signal.End_element" class="def variant constructor anchored"><a href="#type-signal.End_element" class="anchor"></a><code><span>| </span><span>`End_element</span></code></li><li id="type-signal.Text" class="def variant constructor anchored"><a href="#type-signal.Text" class="anchor"></a><code><span>| </span><span>`Text <span class="keyword">of</span> <span>string list</span></span></code></li><li id="type-signal.Doctype" class="def variant constructor anchored"><a href="#type-signal.Doctype" class="anchor"></a><code><span>| </span><span>`Doctype <span class="keyword">of</span> <a href="#type-doctype">doctype</a></span></code></li><li id="type-signal.Xml" class="def variant constructor anchored"><a href="#type-signal.Xml" class="anchor"></a><code><span>| </span><span>`Xml <span class="keyword">of</span> <a href="#type-xml_declaration">xml_declaration</a></span></code></li><li id="type-signal.PI" class="def variant constructor anchored"><a href="#type-signal.PI" class="anchor"></a><code><span>| </span><span>`PI <span class="keyword">of</span> string * string</span></code></li><li id="type-signal.Comment" class="def variant constructor anchored"><a href="#type-signal.Comment" class="anchor"></a><code><span>| </span><span>`Comment <span class="keyword">of</span> string</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Parsing signals. The parsers emit them according to the following grammar:</p><pre class="language-ocaml"><code>doc     ::= `Xml? misc* `Doctype? misc* element misc*
misc    ::= `PI | `Comment
element ::= `Start_element content* `End_element
content ::= `Text | element | `PI | `Comment</code></pre><p>As a result, emitted <code>`Start_element</code> and <code>`End_element</code> signals are always balanced, and, if there is an XML declaration, it is the first signal.</p><p>If parsing with <code>~context:`Document</code>, the signal sequence will match the <code>doc</code> production until the first error. If parsing with <code>~context:`Fragment</code>, it will match <code>content*</code>. If <code>~context</code> is not specified, the parser will pick one of the two by examining the input.</p><p>As an example, if the XML parser is parsing</p><pre class="language-ocaml"><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;root&gt;text&lt;nested&gt;more text&lt;/nested&gt;&lt;/root&gt;</code></pre><p>it will emit the signal sequence</p><pre class="language-ocaml"><code>`Xml {version = &quot;1.0&quot;; encoding = None; standalone = None}
`Start_element ((&quot;&quot;, &quot;root&quot;), [])
`Text [&quot;text&quot;]
`Start_element ((&quot;&quot;, &quot;nested&quot;), [])
`Text [&quot;more text&quot;]
`End_element
`End_element</code></pre><p>The <code>`Text</code> signal carries a <code>string list</code> instead of a single <code>string</code> because on 32-bit platforms, OCaml strings cannot be larger than 16MB. In case the parsers encounter a very long sequence of text, one whose length exceeds about <code>Sys.max_string_length / 2</code>, they will emit a <code>`Text</code> signal with several strings.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-signal_to_string"><a href="#val-signal_to_string" class="anchor"></a><code><span><span class="keyword">val</span> signal_to_string : <span><span>[&lt; <a href="#type-signal">signal</a> ]</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Provides a human-readable representation of signals for debugging.</p></div></div><h3 id="parsers"><a href="#parsers" class="anchor"></a>Parsers</h3><div class="odoc-spec"><div class="spec type anchored" id="type-parser"><a href="#type-parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>'s parser</span></span></code></div><div class="spec-doc"><p>An <code>'s parser</code> is a thin wrapper around a <code>(signal, 's) stream</code> that supports access to additional information that is not carried directly in the stream, such as source locations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-signals"><a href="#val-signals" class="anchor"></a><code><span><span class="keyword">val</span> signals : <span><span><span class="type-var">'s</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Converts a parser to its underlying signal stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-location"><a href="#val-location" class="anchor"></a><code><span><span class="keyword">val</span> location : <span><span><span class="type-var">_</span> <a href="#type-parser">parser</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-location">location</a></span></code></div><div class="spec-doc"><p>Evaluates to the location of the last signal emitted on the parser's signal stream. If no signals have yet been emitted, evaluates to <code>(1, 1)</code>.</p></div></div><h3 id="xml"><a href="#xml" class="anchor"></a>XML</h3><div class="odoc-spec"><div class="spec value anchored" id="val-parse_xml"><a href="#val-parse_xml" class="anchor"></a><code><span><span class="keyword">val</span> parse_xml : 
  <span><span class="optlabel">?report</span>:<span>(<span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Error/index.html#type-t">Error.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?encoding</span>:<a href="Encoding/index.html#type-t">Encoding.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?namespace</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?entity</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context</span>:<span>[&lt; `Document <span>| `Fragment</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(char, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'s</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p>Creates a parser that converts an XML byte stream to a signal stream.</p><p>For simple usage, <code>string &quot;foo&quot; |&gt; parse_xml |&gt; signals</code>.</p><p>If <code>~report</code> is provided, <code>report</code> is called for every error encountered. You may raise an exception in <code>report</code>, and it will propagate to the code reading the signal stream.</p><p>If <code>~encoding</code> is <em>not</em> specified, the parser detects the input encoding automatically. Otherwise, the given encoding is used.</p><p><code>~namespace</code> is called when the parser is unable to resolve a namespace prefix. If it evaluates to <code>Some s</code>, the parser maps the prefix to <code>s</code>. Otherwise, the parser reports <code>`Bad_namespace</code>.</p><p><code>~entity</code> is called when the parser is unable to resolve an entity reference. If it evaluates to <code>Some s</code>, the parser inserts <code>s</code> into the text or attribute being parsed without any further parsing of <code>s</code>. <code>s</code> is assumed to be encoded in UTF-8. If <code>entity</code> evaluates to <code>None</code> instead, the parser reports <code>`Bad_token</code>. See <a href="#val-xhtml_entity"><code>xhtml_entity</code></a> if you are parsing XHTML.</p><p>The meaning of <code>~context</code> is described at <a href="#type-signal"><code>signal</code></a>, above.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_xml"><a href="#val-write_xml" class="anchor"></a><code><span><span class="keyword">val</span> write_xml : 
  <span><span class="optlabel">?report</span>:<span>(<span><span>(<a href="#type-signal">signal</a> * int)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Error/index.html#type-t">Error.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?prefix</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(char, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Converts an XML signal stream to a byte stream.</p><p>If <code>~report</code> is provided, it is called for every error encountered. The first argument is a pair of the signal causing the error and its index in the signal stream. You may raise an exception in <code>report</code>, and it will propagate to the code reading the byte stream.</p><p><code>~prefix</code> is called when the writer is unable to find a prefix in scope for a namespace URI. If it evaluates to <code>Some s</code>, the writer uses <code>s</code> for the URI. Otherwise, the writer reports <code>`Bad_namespace</code>.</p></div></div><h3 id="html"><a href="#html" class="anchor"></a>HTML</h3><div class="odoc-spec"><div class="spec value anchored" id="val-parse_html"><a href="#val-parse_html" class="anchor"></a><code><span><span class="keyword">val</span> parse_html : 
  <span><span class="optlabel">?report</span>:<span>(<span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Error/index.html#type-t">Error.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?encoding</span>:<a href="Encoding/index.html#type-t">Encoding.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context</span>:<span>[&lt; `Document <span><span>| `Fragment</span> of string</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(char, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'s</span> <a href="#type-parser">parser</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-parse_xml"><code>parse_xml</code></a>, but parses HTML with embedded SVG and MathML, never emits signals <code>`Xml</code> or <code>`PI</code>, and <code>~context</code> has a different type on tag <code>`Fragment</code>.</p><p>For HTML fragments, you should specify the enclosing element, e.g. <code>`Fragment &quot;body&quot;</code>. This is because, when parsing HTML, error recovery and the interpretation of text depend on the current element. For example, the text</p><pre class="language-ocaml"><code>foo&lt;/bar&gt;</code></pre><p>parses differently in <code>title</code> elements than in <code>p</code> elements. In the former, it is parsed as <code>foo&lt;/bar&gt;</code>, while in the latter, it is <code>foo</code> followed by a parse error due to unmatched tag <code>&lt;/bar&gt;</code>. To get these behaviors, set <code>~context</code> to <code>`Fragment &quot;title&quot;</code> and <code>`Fragment &quot;p&quot;</code>, respectively.</p><p>If you use <code>`Fragment &quot;svg&quot;</code>, the fragment is assumed to be SVG markup. Likewise, <code>`Fragment &quot;math&quot;</code> causes the parser to parse MathML markup.</p><p>If <code>~context</code> is omitted, the parser guesses it from the input stream. For example, if the first signal would be <code>`Doctype</code>, the context is set to <code>`Document</code>, but if the first signal would be <code>`Start_element &quot;td&quot;</code>, the context is set to <code>`Fragment &quot;tr&quot;</code>. If the first signal would be <code>`Start_element &quot;g&quot;</code>, the context is set to <code>`Fragment &quot;svg&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_html"><a href="#val-write_html" class="anchor"></a><code><span><span class="keyword">val</span> write_html : 
  <span><span class="optlabel">?escape_attribute</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?escape_text</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(char, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-write_xml"><code>write_xml</code></a>, but emits HTML5 instead of XML. If <code>~escape_attribute</code> and/or <code>~escape_text</code> are provided, they are used instead of default escaping functions.</p></div></div><h3 id="input-sources"><a href="#input-sources" class="anchor"></a>Input sources</h3><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Evaluates to a stream that retrieves successive bytes from the given string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-buffer"><a href="#val-buffer" class="anchor"></a><code><span><span class="keyword">val</span> buffer : <span><a href="../../../stdlib/Stdlib/Buffer/index.html#type-t">Buffer.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Evaluates to a stream that retrieves successive bytes from the given buffer. Be careful of changing the buffer while it is being iterated by the stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-channel"><a href="#val-channel" class="anchor"></a><code><span><span class="keyword">val</span> channel : <span><a href="../../../stdlib/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Evaluates to a stream that retrieves bytes from the given channel. If the channel cannot be read, the next read of the stream results in raising <code>Sys_error</code>.</p><p>Note that this input source is synchronous because <code>Pervasives.in_channel</code> reads are blocking. For non-blocking channels, see <code>Markup_lwt_unix</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-file"><a href="#val-file" class="anchor"></a><code><span><span class="keyword">val</span> file : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> * <span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span></span></code></div><div class="spec-doc"><p><code>file path</code> opens the file at <code>path</code>, then evaluates to a pair <code>s, close</code>, where reading from stream <code>s</code> retrieves successive bytes from the file, and calling <code>close ()</code> closes the file.</p><p>The file is closed automatically if <code>s</code> is read to completion, or if reading <code>s</code> raises an exception. It is not necessary to call <code>close ()</code> in these cases.</p><p>If the file cannot be opened, raises <code>Sys_error</code> immediately. If the file cannot be read, reading the stream raises <code>Sys_error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fn"><a href="#val-fn" class="anchor"></a><code><span><span class="keyword">val</span> fn : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>char option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>fn f</code> is a stream that retrives bytes by calling <code>f ()</code>. If the call results in <code>Some c</code>, the stream emits <code>c</code>. If the call results in <code>None</code>, the stream is considered to have ended.</p><p>This is actually an alias for <a href="#val-stream"><code>stream</code></a>, restricted to type <code>char</code>.</p></div></div><h3 id="output-destinations"><a href="#output-destinations" class="anchor"></a>Output destinations</h3><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Eagerly retrieves bytes from the given stream and assembles a string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span><span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../../../stdlib/Stdlib/Buffer/index.html#type-t">Buffer.t</a></span></code></div><div class="spec-doc"><p>Eagerly retrieves bytes from the given stream and places them into a buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span><span class="keyword">val</span> to_channel : <span><a href="../../../stdlib/Stdlib/index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Eagerly retrieves bytes from the given stream and writes them to the given channel. If writing fails, raises <code>Sys_error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span><span class="keyword">val</span> to_file : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(char, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Eagerly retrieves bytes from the given stream and writes them to the given file. If writing fails, or the file cannot be opened, raises <code>Sys_error</code>. Note that the file is truncated (cleared) before writing. If you wish to append to file, open it with the appropriate flags and use <code>to_channel</code> on the resulting channel.</p></div></div><h3 id="stream-operations"><a href="#stream-operations" class="anchor"></a>Stream operations</h3><div class="odoc-spec"><div class="spec value anchored" id="val-stream"><a href="#val-stream" class="anchor"></a><code><span><span class="keyword">val</span> stream : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>stream f</code> creates a stream that repeatedly calls <code>f ()</code>. Each time <code>f ()</code> evaluates to <code>Some v</code>, the next item in the stream is <code>v</code>. The first time <code>f ()</code> evaluates to <code>None</code>, the stream ends.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next"><a href="#val-next" class="anchor"></a><code><span><span class="keyword">val</span> next : <span><span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Retrieves the next item in the stream, if any, and removes it from the stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Retrieves the next item in the stream, if any, but does not remove the item from the stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transform"><a href="#val-transform" class="anchor"></a><code><span><span class="keyword">val</span> transform : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span> * <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'c</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>transform f init s</code> lazily creates a stream by repeatedly applying <code>f acc v</code>, where <code>acc</code> is an accumulator whose initial value is <code>init</code>, and <code>v</code> is consecutive values of <code>s</code>. Each time, <code>f acc v</code> evaluates to a pair <code>(vs, maybe_acc')</code>. The values <code>vs</code> are added to the result stream. If <code>maybe_acc'</code> is <code>Some acc'</code>, the accumulator is set to <code>acc'</code>. Otherwise, if <code>maybe_acc'</code> is <code>None</code>, the result stream ends.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold f init s</code> eagerly folds over the items <code>v</code>, <code>v'</code>, <code>v''</code>, ... of <code>s</code>, i.e. evaluates <code>f (f (f init v) v') v''</code>...</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>map f s</code> lazily applies <code>f</code> to each item of <code>s</code>, and produces the resulting stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>filter f s</code> is <code>s</code> without the items for which <code>f</code> evaluates to <code>false</code>. <code>filter</code> is lazy.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f s</code> lazily applies <code>f</code> to each item <code>v</code> of <code>s</code>. If <code>f v</code> evaluates to <code>Some v'</code>, the result stream has <code>v'</code>. If <code>f v</code> evaluates to <code>None</code>, no item corresponding to <code>v</code> appears in the result stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f s</code> eagerly applies <code>f</code> to each item of <code>s</code>, i.e. evaluates <code>f v; f v'; f v''</code>...</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>drain s</code> eagerly consumes <code>s</code>. This is useful for observing side effects, such as parsing errors, when you don't care about the parsing signals themselves. It is equivalent to <code>iter ignore s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Produces a (lazy) stream from the given list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span>(<span class="type-var">'a</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Eagerly converts the given stream to a list.</p></div></div><h3 id="utility"><a href="#utility" class="anchor"></a>Utility</h3><div class="odoc-spec"><div class="spec value anchored" id="val-content"><a href="#val-content" class="anchor"></a><code><span><span class="keyword">val</span> content : <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Filters out all signals besides <code>`Start_element</code>, <code>`End_element</code>, and <code>`Text</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tree"><a href="#val-tree" class="anchor"></a><code><span><span class="keyword">val</span> tree : 
  <span><span class="optlabel">?text</span>:<span>(<span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?element</span>:<span>(<span><a href="#type-name">name</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-name">name</a> * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?comment</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pi</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?xml</span>:<span>(<span><a href="#type-xml_declaration">xml_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?doctype</span>:<span>(<span><a href="#type-doctype">doctype</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>This function's type signature may look intimidating, but it is actually easy to use. It is best introduced by example:</p><pre class="language-ocaml"><code>type my_dom = Text of string | Element of name * my_dom list

&quot;&lt;p&gt;HTML5 is &lt;em&gt;easy&lt;/em&gt; to parse&quot;
|&gt; string
|&gt; parse_html
|&gt; signals
|&gt; tree
  ~text:(fun ss -&gt; Text (String.concat &quot;&quot; ss))
  ~element:(fun (_ns, name) _attrs children -&gt; Element (name, children))</code></pre><p>results in the structure</p><pre class="language-ocaml"><code>Element (&quot;p&quot; [
  Text &quot;HTML5 is &quot;;
  Element (&quot;em&quot;, [Text &quot;easy&quot;]);
  Text &quot; to parse&quot;])</code></pre><p>Formally, <code>tree</code> assembles a tree data structure of type <code>'a</code> from a signal stream. The stream is parsed according to the following grammar:</p><pre class="language-ocaml"><code>stream  ::= node*
node    ::= element | `Text | `Comment | `PI | `Xml | `Doctype
element ::= `Start_element node* `End_element</code></pre><p>Each time <code>tree</code> matches a production of <code>node</code>, it calls the corresponding function to convert the node into your tree type <code>'a</code>. For example, when <code>tree</code> matches <code>`Text ss</code>, it calls <code>~text ss</code>, if <code>~text</code> is supplied. Similarly, when <code>tree</code> matches <code>element</code>, it calls <code>~element name attributes children</code>, if <code>~element</code> is supplied.</p><p><code>tree</code> returns <code>None</code> when its input signal stream is empty. In terms of the original input bytes, this can correspond to either an empty input, or a non-empty input which the parser's error recovery completely discarded, producing no signals.</p><p>See <a href="#val-trees"><code>trees</code></a> if the input stream might have multiple top-level trees. This function <code>tree</code> only retrieves the first one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trees"><a href="#val-trees" class="anchor"></a><code><span><span class="keyword">val</span> trees : 
  <span><span class="optlabel">?text</span>:<span>(<span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?element</span>:<span>(<span><a href="#type-name">name</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-name">name</a> * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?comment</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?pi</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?xml</span>:<span>(<span><a href="#type-xml_declaration">xml_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?doctype</span>:<span>(<span><a href="#type-doctype">doctype</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-tree"><code>tree</code></a>, but converts all top-level trees, not only the first one. The trees are emitted on the resulting stream, in the sequence that they appear in the input.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a node</span></span><span> = </span><span>[ </span></code><ol><li id="type-node.Element" class="def variant constructor anchored"><a href="#type-node.Element" class="anchor"></a><code><span>| </span><span>`Element <span class="keyword">of</span> <a href="#type-name">name</a> * <span><span>(<a href="#type-name">name</a> * string)</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></li><li id="type-node.Text" class="def variant constructor anchored"><a href="#type-node.Text" class="anchor"></a><code><span>| </span><span>`Text <span class="keyword">of</span> string</span></code></li><li id="type-node.Doctype" class="def variant constructor anchored"><a href="#type-node.Doctype" class="anchor"></a><code><span>| </span><span>`Doctype <span class="keyword">of</span> <a href="#type-doctype">doctype</a></span></code></li><li id="type-node.Xml" class="def variant constructor anchored"><a href="#type-node.Xml" class="anchor"></a><code><span>| </span><span>`Xml <span class="keyword">of</span> <a href="#type-xml_declaration">xml_declaration</a></span></code></li><li id="type-node.PI" class="def variant constructor anchored"><a href="#type-node.PI" class="anchor"></a><code><span>| </span><span>`PI <span class="keyword">of</span> string * string</span></code></li><li id="type-node.Comment" class="def variant constructor anchored"><a href="#type-node.Comment" class="anchor"></a><code><span>| </span><span>`Comment <span class="keyword">of</span> string</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>See <a href="#val-from_tree"><code>from_tree</code></a> below.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_tree"><a href="#val-from_tree" class="anchor"></a><code><span><span class="keyword">val</span> from_tree : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-node">node</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-signal">signal</a>, <a href="#type-sync">sync</a>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Deconstructs tree data structures of type <code>'a</code> into signal streams. The function argument is applied to each data structure node. For example,</p><pre class="language-ocaml"><code>type my_dom = Text of string | Element of string * my_dom list

let dom =
  Element (&quot;p&quot;, [
    Text &quot;HTML5 is &quot;;
    Element (&quot;em&quot;, [Text &quot;easy&quot;]);
    Text &quot; to parse&quot;])

dom |&gt; from_tree (function
  | Text s -&gt; `Text s
  | Element (name, children) -&gt; `Element ((&quot;&quot;, name), [], children))</code></pre><p>results in the signal stream</p><pre class="language-ocaml"><code>`Start_element ((&quot;&quot;, &quot;p&quot;), [])
`Text [&quot;HTML5 is &quot;]
`Start_element ((&quot;&quot;, &quot;em&quot;), [])
`Text [&quot;easy&quot;]
`End_element
`Text &quot; to parse&quot;
`End_element</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span><span class="keyword">val</span> elements : 
  <span><span>(<span><a href="#type-name">name</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-name">name</a> * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span> <span class="keyword">as</span> 'a, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>elements f s</code> scans the signal stream <code>s</code> for <code>`Start_element (name, attributes)</code> signals that satisfy <code>f name attributes</code>. Each such matching signal is the beginning of a substream that ends with the corresponding <code>`End_element</code> signal. The result of <code>elements f s</code> is the stream of these substreams.</p><p>Matches don't nest. If there is a matching element contained in another matching element, only the top one results in a substream.</p><p>Code using <code>elements</code> does not have to read each substream to completion, or at all. However, once the using code has tried to get the next substream, it should not try to read a previous one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-text"><a href="#val-text" class="anchor"></a><code><span><span class="keyword">val</span> text : <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Extracts all the text in a signal stream by discarding all markup. For each <code>`Text ss</code> signal, the result stream has the bytes of the strings <code>ss</code>, and all other signals are ignored.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span><span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Trims insignificant whitespace in an HTML signal stream. Whitespace around flow (&quot;block&quot;) content does not matter, but whitespace in phrasing (&quot;inline&quot;) content does. So, if the input stream is</p><pre class="language-ocaml"><code>&lt;div&gt;
 &lt;p&gt;
  &lt;em&gt;foo&lt;/em&gt; bar
 &lt;/p&gt;
&lt;/div&gt;</code></pre><p>passing it through <code>Markup.trim</code> will result in</p><pre class="language-ocaml"><code>&lt;div&gt;&lt;p&gt;&lt;em&gt;foo&lt;/em&gt; bar&lt;/p&gt;&lt;/div&gt;</code></pre><p>Note that whitespace around the <code>&lt;/em&gt;</code> tag was preserved.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-normalize_text"><a href="#val-normalize_text" class="anchor"></a><code><span><span class="keyword">val</span> normalize_text : 
  <span><span><span>(<span>[&gt; <span>`Text of <span>string list</span></span> ]</span> <span class="keyword">as</span> 'a, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Concatenates adjacent <code>`Text</code> signals, then eliminates all empty strings, then all <code>`Text []</code> signals. Signals besides <code>`Text</code> are unaffected. Note that signal streams emitted by the parsers already have normalized text. This function is useful when you are inserting text into a signal stream after parsing, or generating streams from scratch, and would like to clean up the <code>`Text</code> signals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span><span class="keyword">val</span> pretty_print : <span><span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Adjusts the whitespace in the <code>`Text</code> signals in the given stream so that the output appears nicely-indented when the stream is converted to bytes and written.</p><p>This function is aware of the significance of whitespace in HTML, so it avoids changing the whitespace in phrasing (&quot;inline&quot;) content. For example, pretty printing</p><pre class="language-ocaml"><code>&lt;div&gt;&lt;p&gt;&lt;em&gt;foo&lt;/em&gt;bar&lt;/p&gt;&lt;/div&gt;</code></pre><p>results in</p><pre class="language-ocaml"><code>&lt;div&gt;
 &lt;p&gt;
  &lt;em&gt;foo&lt;/em&gt;bar
 &lt;/p&gt;
&lt;/div&gt;</code></pre><p>Note that no whitespace was inserted around <code>&lt;em&gt;</code> and <code>&lt;/em&gt;</code>, because doing so would create a word break that wasn't present in the original stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-html5"><a href="#val-html5" class="anchor"></a><code><span><span class="keyword">val</span> html5 : <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Converts a signal stream into an HTML5 signal stream by stripping any document type declarations, XML declarations, and processing instructions, and prefixing the HTML5 doctype declaration. This is useful when converting between XHTML and HTML.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xhtml"><a href="#val-xhtml" class="anchor"></a><code><span><span class="keyword">val</span> xhtml : 
  <span><span class="optlabel">?dtd</span>:<span>[&lt; `Strict_1_0 <span>| `Transitional_1_0</span> <span>| `Frameset_1_0</span> <span>| `Strict_1_1</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[&lt; <a href="#type-signal">signal</a> ]</span>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-signal">signal</a>, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-html5"><code>html5</code></a>, but does not strip processing instructions, and prefixes an XHTML document type declaration and an XML declaration. The <code>~dtd</code> argument specifies which DTD to refer to in the doctype declaration. The default is <code>`Strict_1_1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xhtml_entity"><a href="#val-xhtml_entity" class="anchor"></a><code><span><span class="keyword">val</span> xhtml_entity : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p>Translates XHTML entities. This function is for use with the <code>~entity</code> argument of <a href="#val-parse_xml"><code>parse_xml</code></a> when parsing XHTML.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-strings_to_bytes"><a href="#val-strings_to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> strings_to_bytes : <span><span><span>(string, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(char, <span class="type-var">'s</span>)</span> <a href="#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>strings_to_bytes s</code> is the stream of all the bytes of all strings in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_locations"><a href="#val-compare_locations" class="anchor"></a><code><span><span class="keyword">val</span> compare_locations : <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Orders locations according to their appearance in an input stream, i.e. first by line, and then, for locations on the same line, by column.</p></div></div><h3 id="namespaces"><a href="#namespaces" class="anchor"></a>Namespaces</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Ns"><a href="#module-Ns" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ns/index.html">Ns</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Common namespace URIs.</p></div></div><h3 id="asynchronous-interface"><a href="#asynchronous-interface" class="anchor"></a>Asynchronous interface</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-ASYNCHRONOUS"><a href="#module-type-ASYNCHRONOUS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ASYNCHRONOUS/index.html">ASYNCHRONOUS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Markup.ml interface for monadic I/O libraries such as Lwt and Async.</p></div></div><h3 id="conformance-status"><a href="#conformance-status" class="anchor"></a>Conformance status</h3><p>The HTML parser seeks to implement <a href="https://www.w3.org/TR/html5/syntax.html">section 8 of the HTML5 specification</a>. That section describes a parser, part of a full-blown user agent, that is building up a DOM representation of an HTML document. Markup.ml is neither inherently part of a user agent, nor does it build up a DOM representation. With respect to section 8 of HTML5, Markup.ml is concerned with only the syntax. When that section requires that the user agent perform an action, Markup.ml emits enough information for a hypothetical user agent based on it to be able to decide to perform this action. Likewise, Markup.ml seeks to emit enough information for a hypothetical user agent to build up a conforming DOM.</p><p>The XML parser seeks to be a non-validating implementation of the <a href="https://www.w3.org/TR/xml/">XML</a> and <a href="https://www.w3.org/TR/xml-names/">Namespaces in XML</a> specifications.</p><p>This rest of this section lists known deviations from HTML5, XML, and Namespaces in XML. Some of these deviations are meant to be corrected in future versions of Markup.ml, while others will probably remain. The latter satisfy some or all of the following properties:</p><ul><li>They require non-local adjustment, especially of past nodes. For example, adjusting the start signal of the root node mid-way through the signal stream is difficult for a one-pass parser.</li><li>They are minor. Users implementing less than a conforming browser typically don't care about them. They typically have to do with obscure error recovery. There are no deviations affecting the parsing of well-formed input.</li><li>They can easily be corrected by code written over Markup.ml that builds up a DOM or maintains other auxiliary data structures during parsing.</li></ul><h4 id="to-be-corrected:"><a href="#to-be-corrected:" class="anchor"></a>To be corrected:</h4><ul><li>XML: There is no attribute value normalization.</li><li>HTML: <em>foster parenting</em> is not implemented, because it requires non-local adjustments.</li><li>HTML: Quirks mode is not honored. This affects the interaction between automatic closing of <code>p</code> elements and opening of <code>table</code> elements.</li><li>HTML: The parser has non-standard recovery from unmatched closing <code>form</code> tags in <a href="https://github.com/aantron/markup.ml/commit/0bf4f1b">some situations</a>.</li><li>HTML: The parser ignores interactions between <code>form</code> and <code>template</code>.</li><li>HTML: The form translation for <code>isindex</code> is completely ignored. <code>isindex</code> is handled as an unknown element.</li></ul><h4 id="to-remain:"><a href="#to-remain:" class="anchor"></a>To remain:</h4><ul><li>HTML: Except when detecting encodings, the parser does not try to read <code>&lt;meta&gt;</code> tags for encoding declarations. The user of Markup.ml should read these, if necessary. They are part of the emitted signal stream.</li><li>HTML: <code>noscript</code> elements are always parsed, as are <code>script</code> elements. For conforming behavior, if the user of Markup.ml &quot;supports scripts,&quot; the user should serialize the content of <code>noscript</code> to a <code>`Text</code> signal using <code>write_html</code>.</li><li>HTML: Elements such as <code>title</code> that belong in <code>head</code>, but are found between <code>head</code> and <code>body</code>, are not moved into <code>head</code>.</li><li>HTML: <code>&lt;html&gt;</code> tags found in the body do not have their attributes added to the <code>`Start_element &quot;html&quot;</code> signal emitted at the beginning of the document.</li></ul></div></body></html>
