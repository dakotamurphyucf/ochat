<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Oauth2_manager (ochat.Oauth2_manager)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Oauth2_manager</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Oauth2_manager</span></code></h1><p>OAuth 2.0 token management with transparent caching.</p><p>This module provides a thin wrapper around the lower-level helpers in the <a href="../Oauth2_client_credentials/index.html"><code>Oauth2_client_credentials</code></a> and <a href="../Oauth2_pkce_flow/index.html"><code>Oauth2_pkce_flow</code></a> sub-modules. It handles:</p><p>‚Ä¢ Discovering the authorisation‚Äêserver metadata (with a sensible fallback when the <code>/.well-known/oauth-authorization-server</code> endpoint is absent). ‚Ä¢ Retrieving an access / refresh token using either the *Client Credentials* grant or the interactive *PKCE* flow. ‚Ä¢ Persisting the returned token in the user‚Äôs XDG cache directory (or <code>$HOME/.cache</code> on systems without XDG) so subsequent runs start up instantly. ‚Ä¢ Refreshing the token whenever fewer than 60 s remain before expiry.</p><p>The helper is entirely <b>exception-free</b>. All recoverable error paths return <code>Error msg</code> where <code>msg</code> provides a short, human-readable diagnostic.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#credentials">Credentials</a></li><li><a href="#quick-start">Quick start</a></li></ul></nav></div><div class="odoc-content"><h2 id="credentials"><a href="#credentials" class="anchor"></a>Credentials</h2><p>The <code>creds</code> variant captures the two supported client types:</p><ul><li><code>`Client_secret</code> ‚Äî confidential clients that know a <code>client_secret</code> and therefore use the RFC&amp;nbsp;6749 ¬ß4.4 *client-credentials* grant.</li><li><code>`Pkce</code> ‚Äî public clients (CLI / desktop apps) that rely on the user completing a browser-based *PKCE* dance.</li></ul><h2 id="quick-start"><a href="#quick-start" class="anchor"></a>Quick start</h2><pre class="language-ocaml"><code>  Eio_main.run @@ fun env -&gt;
    Eio.Switch.run @@ fun sw -&gt;
      match
        Oauth2_manager.get
          ~env ~sw
          ~issuer:&quot;https://auth.example&quot;
          (Client_secret
             { id     = &quot;my-service&quot;
             ; secret = Sys.getenv_exn &quot;CLIENT_SECRET&quot;
             ; scope  = Some &quot;openid profile&quot;
             })
      with
      | Error msg -&gt; Format.eprintf &quot;Token error: %s@.&quot; msg
      | Ok tok -&gt;
          Format.printf &quot;Bearer %s@.&quot; tok.access_token</code></pre><div class="odoc-spec"><div class="spec module anchored" id="module-Result"><a href="#module-Result" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Result/index.html">Result</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Tok"><a href="#module-Tok" class="anchor"></a><code><span><span class="keyword">module</span> Tok</span><span> = <a href="../Oauth2_types/Token/index.html">Oauth2_types.Token</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cache_dir"><a href="#val-cache_dir" class="anchor"></a><code><span><span class="keyword">val</span> cache_dir : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>cache_dir ()</code> yields the directory used to persist token JSON files.</p><p>Resolution order follows the XDG Base Directory specification:</p><ol><li><code>$XDG_CACHE_HOME</code> if set</li><li><code>$HOME/.cache</code> on Unix‚Äêlike systems</li><li><code>./.cache</code> as a last resort</li></ol><p>The function does not touch the file-system; callers should create the directory (e.g. via <a href="../Io/index.html#val-mkdir"><code>Io.mkdir</code></a>) before writing files within it.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cache_file"><a href="#val-cache_file" class="anchor"></a><code><span><span class="keyword">val</span> cache_file : <span>string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p><code>cache_file issuer</code> maps an <code>issuer</code> base URL to the absolute path of its token cache file. The issuer string is hashed with MD5 so that extremely long or non-filesystem-safe URLs do not break on exotic platforms. The file is named <code>&lt;md5&gt;.json</code> and always lives under <code>cache_dir ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fallback_metadata"><a href="#val-fallback_metadata" class="anchor"></a><code><span><span class="keyword">val</span> fallback_metadata : <span><span class="label">issuer</span>:string <span class="arrow">&#45;&gt;</span></span> <a href="../Oauth2_types/Metadata/index.html#type-t">Oauth2_types.Metadata.t</a></span></code></div><div class="spec-doc"><p><code>fallback_metadata ~issuer</code> constructs an <a href="../Oauth2_types/Metadata/index.html#type-t"><code>Oauth2_types.Metadata.t</code></a> record directly from the given <code>issuer</code> when the discovery document is missing. Only the three most common endpoints are filled in: <code> /authorize</code>, <code>/token</code>, and <code>/register</code>. All paths are appended to the <em>scheme://host<code>:port</code></em> portion of <code>issuer</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fetch_metadata"><a href="#val-fetch_metadata" class="anchor"></a><code><span><span class="keyword">val</span> fetch_metadata : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">issuer</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Oauth2_types/Metadata/index.html#type-t">Oauth2_types.Metadata.t</a>, string)</span> <a href="Result/index.html#type-t">Result.t</a></span></span></code></div><div class="spec-doc"><p><code>fetch_metadata ~env ~sw ~issuer</code> downloads the <i>Authorization Server Metadata</i> document from <code>issuer ^ &quot;/.well-known/oauth-authorization-server&quot;</code>.</p><p>If the HTTPS request fails or the payload cannot be decoded the helper silently falls back to <a href="#val-fallback_metadata"><code>fallback_metadata</code></a>, ensuring that flows that hard-code the conventional endpoint names continue to work.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load"><a href="#val-load" class="anchor"></a><code><span><span class="keyword">val</span> load : 
  <span><span class="label">env</span>:<span>&lt; fs : <span><span>[&gt; <span class="xref-unresolved">Eio__</span>.Fs.dir_ty ]</span> <span class="xref-unresolved">Eio</span>.Path.t</span>.. &gt;</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Oauth2_types/Token/index.html#type-t">Tok.t</a>, string)</span> <a href="Result/index.html#type-t">Result.t</a></span></span></code></div><div class="spec-doc"><p><code>load ~env issuer</code> attempts to read a previously cached token for <code>issuer</code>. For security the file must be readable and writable <b>only</b> by the current user; otherwise <code>Error &quot;insecure_token_cache_permissions&quot;</code> is returned. Any other I/O or decoding error yields <code>Error &quot;token_cache_read&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store"><a href="#val-store" class="anchor"></a><code><span><span class="keyword">val</span> store : <span><span class="label">env</span>:<span>&lt; fs : <span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span>.. &gt;</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../Oauth2_types/Token/index.html#type-t">Tok.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store ~env issuer tok</code> atomically writes <code>tok</code> to disk using <code>`Or_truncate 0o600</code> permissions. Errors are swallowed on purpose ‚Äì the function is best-effort and should never crash the application.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-creds"><a href="#type-creds" class="anchor"></a><code><span><span class="keyword">type</span> creds</span><span> = </span></code><ol><li id="type-creds.Client_secret" class="def variant constructor anchored"><a href="#type-creds.Client_secret" class="anchor"></a><code><span>| </span><span><span class="constructor">Client_secret</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-creds.id" class="def record field anchored"><a href="#type-creds.id" class="anchor"></a><code><span>id : string;</span></code></li><li id="type-creds.secret" class="def record field anchored"><a href="#type-creds.secret" class="anchor"></a><code><span>secret : string;</span></code></li><li id="type-creds.scope" class="def record field anchored"><a href="#type-creds.scope" class="anchor"></a><code><span>scope : <span>string option</span>;</span></code></li></ol><code><span>}</span></code></li><li id="type-creds.Pkce" class="def variant constructor anchored"><a href="#type-creds.Pkce" class="anchor"></a><code><span>| </span><span><span class="constructor">Pkce</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-creds.client_id" class="def record field anchored"><a href="#type-creds.client_id" class="anchor"></a><code><span>client_id : string;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>Credentials used by <a href="#val-get"><code>get</code></a>, <a href="#val-obtain"><code>obtain</code></a>, and <a href="#val-refresh_access_token"><code>refresh_access_token</code></a>.</p></div></div><ul><li><code>`Client_secret</code> ‚Äî confidential clients possessing a private <code>client_secret</code> and therefore eligible for the *client-credentials* grant. Provide <code>scope</code> to narrow the issued privileges.</li><li><code>`Pkce</code> ‚Äî public clients (desktop / CLI) that must perform the browser-based PKCE flow.</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-refresh_access_token"><a href="#val-refresh_access_token" class="anchor"></a><code><span><span class="keyword">val</span> refresh_access_token : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">issuer</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-creds">creds</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Oauth2_types/Token/index.html#type-t">Tok.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Oauth2_types/Token/index.html#type-t">Tok.t</a>, string)</span> <a href="Result/index.html#type-t">Result.t</a></span></span></code></div><div class="spec-doc"><p><code>refresh_access_token ~env ~sw ~issuer creds tok</code> exchanges <code>tok.refresh_token</code> for a fresh access token.</p><ul><li>For <code>`Client_secret</code> clients the helper performs a standard *refresh_token* grant at <code>issuer ^ &quot;/token&quot;</code>.</li><li>For <code>`Pkce</code> clients the grant is POST-ed to the metadata‚Äôs <code>token_endpoint</code>.</li></ul><p>Returned tokens are stamped with the current wall-clock time so that <a href="../Oauth2_types/Token/index.html#val-is_expired"><code>Oauth2_types.Token.is_expired</code></a> works reliably.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obtain"><a href="#val-obtain" class="anchor"></a><code><span><span class="keyword">val</span> obtain : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-creds">creds</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Oauth2_types/Token/index.html#type-t">Oauth2_client_credentials.Tok.t</a>, string)</span> <a href="../Oauth2_client_credentials/Result/index.html#type-t">Oauth2_client_credentials.Result.t</a></span></span></code></div><div class="spec-doc"><p><code>obtain ~env ~sw issuer creds</code> performs the initial grant:</p><p>‚Ä¢ *Client-credentials* for confidential clients ‚Ä¢ Interactive *PKCE* flow for public clients</p><p>The function is usually not called directly ‚Äì use <a href="#val-get"><code>get</code></a> instead which combines caching, refreshing, and initial acquisition.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">issuer</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-creds">creds</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Oauth2_types/Token/index.html#type-t">Tok.t</a>, string)</span> <a href="Result/index.html#type-t">Result.t</a></span></span></code></div><div class="spec-doc"><p><code>get ~env ~sw ~issuer creds</code> is the main entry-point. It guarantees that the returned token is valid for at least 60 seconds.</p><p>Workflow:</p><ol><li>Try to <code>load</code> the token from disk.</li><li>If present and still fresh ‚áí return immediately.</li><li>If expired ‚áí attempt <a href="#val-refresh_access_token"><code>refresh_access_token</code></a>.</li><li>On refresh failure or missing cache ‚áí <a href="#val-obtain"><code>obtain</code></a>.</li><li>Persist the brand-new token with <code>store</code> before returning.</li></ol><p>All failure cases bubble up as <code>Error msg</code>. The helper never raises exceptions.</p></div></div></div></body></html>
