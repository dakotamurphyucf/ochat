<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chatml_lang (ochat.Chatml.Chatml_lang)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Chatml</a> &#x00BB; Chatml_lang</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chatml.Chatml_lang</span></code></h1><p>ChatML evaluator runtime.</p><p>This module implements the small, statically-typed <em>ChatML</em> language used by the rest of the code-base to describe lightweight scripts in prompts and test-scenarios.</p><p>The code is organised in eight conceptual layers, each introduced by a numbered banner in the source:</p><ol><li>Abstract syntax tree description (section 1).</li><li>Runtime value representation (section 2).</li><li>Helpers for environments and variable lookup (section 3).</li><li>Pattern-matching engine (section 4).</li><li>Tail-call trampoline and frame helpers (sections 5 &amp; 6).</li><li>Statement evaluation (section 7).</li><li>Program evaluation entry-point (section 8).</li></ol><p>Each public type and function is documented individually below. Only the high-level entry point <code>eval_program</code> is intended for external consumers; everything else is provided to make the implementation testable.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-node"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a node</span></span><span> = </span><span>{</span></code><ol><li id="type-node.value" class="def record field anchored"><a href="#type-node.value" class="anchor"></a><code><span>value : <span class="type-var">'a</span>;</span></code></li><li id="type-node.span" class="def record field anchored"><a href="#type-node.span" class="anchor"></a><code><span>span : <a href="../../Source/index.html#type-span">Source.span</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A syntax node annotated with its source code span. The parser wraps every AST fragment in this record so that the evaluator and error reporter can recover position information.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-node_of_sexp"><a href="#val-node_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> node_of_sexp : 'a. <span><span>(<span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-node">node</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_node"><a href="#val-sexp_of_node" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_node : 'a. <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">type</span> pattern</span><span> = </span></code><ol><li id="type-pattern.PWildcard" class="def variant constructor anchored"><a href="#type-pattern.PWildcard" class="anchor"></a><code><span>| </span><span><span class="constructor">PWildcard</span></span></code></li><li id="type-pattern.PVar" class="def variant constructor anchored"><a href="#type-pattern.PVar" class="anchor"></a><code><span>| </span><span><span class="constructor">PVar</span> <span class="keyword">of</span> string</span></code></li><li id="type-pattern.PInt" class="def variant constructor anchored"><a href="#type-pattern.PInt" class="anchor"></a><code><span>| </span><span><span class="constructor">PInt</span> <span class="keyword">of</span> int</span></code></li><li id="type-pattern.PBool" class="def variant constructor anchored"><a href="#type-pattern.PBool" class="anchor"></a><code><span>| </span><span><span class="constructor">PBool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-pattern.PFloat" class="def variant constructor anchored"><a href="#type-pattern.PFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">PFloat</span> <span class="keyword">of</span> float</span></code></li><li id="type-pattern.PString" class="def variant constructor anchored"><a href="#type-pattern.PString" class="anchor"></a><code><span>| </span><span><span class="constructor">PString</span> <span class="keyword">of</span> string</span></code></li><li id="type-pattern.PVariant" class="def variant constructor anchored"><a href="#type-pattern.PVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">PVariant</span> <span class="keyword">of</span> string * <span><a href="#type-pattern">pattern</a> list</span></span></code></li><li id="type-pattern.PRecord" class="def variant constructor anchored"><a href="#type-pattern.PRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">PRecord</span> <span class="keyword">of</span> <span><span>(string * <a href="#type-pattern">pattern</a>)</span> list</span> * bool</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pattern_of_sexp"><a href="#val-pattern_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> pattern_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-pattern">pattern</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_pattern"><a href="#val-sexp_of_pattern" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_pattern : <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_pattern"><a href="#val-compare_pattern" class="anchor"></a><code><span><span class="keyword">val</span> compare_pattern : <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Core__</span>.Import.int</span></code></div></div><p>Abstract patterns used in the surface syntax and by the runtime matcher. The constructors mirror the value space of the language. A record pattern carries a flag indicating whether a trailing <code>_</code> wildcard (&quot;open row&quot;) is present ‚Äì <code>true</code> means additional fields are allowed.</p><div class="odoc-spec"><div class="spec type anchored" id="type-var_loc"><a href="#type-var_loc" class="anchor"></a><code><span><span class="keyword">type</span> var_loc</span><span> = </span><span>{</span></code><ol><li id="type-var_loc.depth" class="def record field anchored"><a href="#type-var_loc.depth" class="anchor"></a><code><span>depth : int;</span></code></li><li id="type-var_loc.index" class="def record field anchored"><a href="#type-var_loc.index" class="anchor"></a><code><span>index : int;</span></code></li><li id="type-var_loc.slot" class="def record field anchored"><a href="#type-var_loc.slot" class="anchor"></a><code><span>slot : <a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Represents the lexical address of a variable after the resolver pass. <code>depth</code> = how many frames to pop (0 = current frame), <code>index</code> = slot inside that frame. The runtime currently stores only <code>Chatml_lang.value</code> values inside frames, therefore we do not need the full GADT-powered descriptor from <code>Frame_env</code> at this stage.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_var_loc"><a href="#val-sexp_of_var_loc" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_var_loc : <span><a href="#type-var_loc">var_loc</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.EInt" class="def variant constructor anchored"><a href="#type-expr.EInt" class="anchor"></a><code><span>| </span><span><span class="constructor">EInt</span> <span class="keyword">of</span> int</span></code></li><li id="type-expr.EBool" class="def variant constructor anchored"><a href="#type-expr.EBool" class="anchor"></a><code><span>| </span><span><span class="constructor">EBool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-expr.EFloat" class="def variant constructor anchored"><a href="#type-expr.EFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">EFloat</span> <span class="keyword">of</span> float</span></code></li><li id="type-expr.EString" class="def variant constructor anchored"><a href="#type-expr.EString" class="anchor"></a><code><span>| </span><span><span class="constructor">EString</span> <span class="keyword">of</span> string</span></code></li><li id="type-expr.EVar" class="def variant constructor anchored"><a href="#type-expr.EVar" class="anchor"></a><code><span>| </span><span><span class="constructor">EVar</span> <span class="keyword">of</span> string</span></code></li><li id="type-expr.EVarLoc" class="def variant constructor anchored"><a href="#type-expr.EVarLoc" class="anchor"></a><code><span>| </span><span><span class="constructor">EVarLoc</span> <span class="keyword">of</span> <a href="#type-var_loc">var_loc</a></span></code></li><li id="type-expr.ELambda" class="def variant constructor anchored"><a href="#type-expr.ELambda" class="anchor"></a><code><span>| </span><span><span class="constructor">ELambda</span> <span class="keyword">of</span> <span>string list</span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ELambdaSlots" class="def variant constructor anchored"><a href="#type-expr.ELambdaSlots" class="anchor"></a><code><span>| </span><span><span class="constructor">ELambdaSlots</span> <span class="keyword">of</span> <span>string list</span> * <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> list</span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.EApp" class="def variant constructor anchored"><a href="#type-expr.EApp" class="anchor"></a><code><span>| </span><span><span class="constructor">EApp</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> list</span></span></code></li><li id="type-expr.EIf" class="def variant constructor anchored"><a href="#type-expr.EIf" class="anchor"></a><code><span>| </span><span><span class="constructor">EIf</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.EWhile" class="def variant constructor anchored"><a href="#type-expr.EWhile" class="anchor"></a><code><span>| </span><span><span class="constructor">EWhile</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ELetIn" class="def variant constructor anchored"><a href="#type-expr.ELetIn" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetIn</span> <span class="keyword">of</span> string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ELetRec" class="def variant constructor anchored"><a href="#type-expr.ELetRec" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetRec</span> <span class="keyword">of</span> <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ELetBlock" class="def variant constructor anchored"><a href="#type-expr.ELetBlock" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetBlock</span> <span class="keyword">of</span> <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ELetBlockSlots" class="def variant constructor anchored"><a href="#type-expr.ELetBlockSlots" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetBlockSlots</span> <span class="keyword">of</span> <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span>
  * <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> list</span>
  * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ELetRecSlots" class="def variant constructor anchored"><a href="#type-expr.ELetRecSlots" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetRecSlots</span> <span class="keyword">of</span> <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span>
  * <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> list</span>
  * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.EMatch" class="def variant constructor anchored"><a href="#type-expr.EMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">EMatch</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><span>(<a href="#type-pattern">pattern</a> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span></span></code></li><li id="type-expr.EMatchSlots" class="def variant constructor anchored"><a href="#type-expr.EMatchSlots" class="anchor"></a><code><span>| </span><span><span class="constructor">EMatchSlots</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>
  * <span><span>(<a href="#type-pattern">pattern</a> * <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> list</span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span></span></code></li><li id="type-expr.ERecord" class="def variant constructor anchored"><a href="#type-expr.ERecord" class="anchor"></a><code><span>| </span><span><span class="constructor">ERecord</span> <span class="keyword">of</span> <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span></span></code></li><li id="type-expr.EFieldGet" class="def variant constructor anchored"><a href="#type-expr.EFieldGet" class="anchor"></a><code><span>| </span><span><span class="constructor">EFieldGet</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * string</span></code></li><li id="type-expr.EFieldSet" class="def variant constructor anchored"><a href="#type-expr.EFieldSet" class="anchor"></a><code><span>| </span><span><span class="constructor">EFieldSet</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.EVariant" class="def variant constructor anchored"><a href="#type-expr.EVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">EVariant</span> <span class="keyword">of</span> string * <span><span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> list</span></span></code></li><li id="type-expr.EArray" class="def variant constructor anchored"><a href="#type-expr.EArray" class="anchor"></a><code><span>| </span><span><span class="constructor">EArray</span> <span class="keyword">of</span> <span><span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> list</span></span></code></li><li id="type-expr.EArrayGet" class="def variant constructor anchored"><a href="#type-expr.EArrayGet" class="anchor"></a><code><span>| </span><span><span class="constructor">EArrayGet</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.EArraySet" class="def variant constructor anchored"><a href="#type-expr.EArraySet" class="anchor"></a><code><span>| </span><span><span class="constructor">EArraySet</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ERef" class="def variant constructor anchored"><a href="#type-expr.ERef" class="anchor"></a><code><span>| </span><span><span class="constructor">ERef</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ESetRef" class="def variant constructor anchored"><a href="#type-expr.ESetRef" class="anchor"></a><code><span>| </span><span><span class="constructor">ESetRef</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ESequence" class="def variant constructor anchored"><a href="#type-expr.ESequence" class="anchor"></a><code><span>| </span><span><span class="constructor">ESequence</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.EDeref" class="def variant constructor anchored"><a href="#type-expr.EDeref" class="anchor"></a><code><span>| </span><span><span class="constructor">EDeref</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-expr.ERecordExtend" class="def variant constructor anchored"><a href="#type-expr.ERecordExtend" class="anchor"></a><code><span>| </span><span><span class="constructor">ERecordExtend</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> * <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_expr"><a href="#val-sexp_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><p>Untyped core language expressions. Variants whose names end with <code>*Slots</code> are produced by the resolver pass and contain pre-computed slot descriptors that guide frame allocation in the evaluator. A regular consumer of the module should never manufacture these directly ‚Äì use <code>Chatml_resolver.resolve</code> instead.</p><div class="odoc-spec"><div class="spec type anchored" id="type-stmt"><a href="#type-stmt" class="anchor"></a><code><span><span class="keyword">type</span> stmt</span><span> = </span></code><ol><li id="type-stmt.SLet" class="def variant constructor anchored"><a href="#type-stmt.SLet" class="anchor"></a><code><span>| </span><span><span class="constructor">SLet</span> <span class="keyword">of</span> string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li><li id="type-stmt.SLetRec" class="def variant constructor anchored"><a href="#type-stmt.SLetRec" class="anchor"></a><code><span>| </span><span><span class="constructor">SLetRec</span> <span class="keyword">of</span> <span><span>(string * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span></span></code></li><li id="type-stmt.SModule" class="def variant constructor anchored"><a href="#type-stmt.SModule" class="anchor"></a><code><span>| </span><span><span class="constructor">SModule</span> <span class="keyword">of</span> string * <span><span><a href="#type-stmt">stmt</a> <a href="#type-node">node</a></span> list</span></span></code></li><li id="type-stmt.SOpen" class="def variant constructor anchored"><a href="#type-stmt.SOpen" class="anchor"></a><code><span>| </span><span><span class="constructor">SOpen</span> <span class="keyword">of</span> string</span></code></li><li id="type-stmt.SExpr" class="def variant constructor anchored"><a href="#type-stmt.SExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">SExpr</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_stmt"><a href="#val-sexp_of_stmt" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_stmt : <span><a href="#type-stmt">stmt</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><p>Top‚Äìlevel statements accepted by the interpreter. The concrete syntax provides syntactic sugar that is desugared into this representation by the parser.</p><div class="odoc-spec"><div class="spec type anchored" id="type-stmt_node"><a href="#type-stmt_node" class="anchor"></a><code><span><span class="keyword">type</span> stmt_node</span><span> = <span><a href="#type-stmt">stmt</a> <a href="#type-node">node</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_stmt_node"><a href="#val-sexp_of_stmt_node" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_stmt_node : <span><a href="#type-stmt_node">stmt_node</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-program"><a href="#type-program" class="anchor"></a><code><span><span class="keyword">type</span> program</span><span> = <span><a href="#type-stmt_node">stmt_node</a> list</span> * string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_program"><a href="#val-sexp_of_program" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_program : <span><a href="#type-program">program</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> value</span><span> = </span></code><ol><li id="type-value.VInt" class="def variant constructor anchored"><a href="#type-value.VInt" class="anchor"></a><code><span>| </span><span><span class="constructor">VInt</span> <span class="keyword">of</span> int</span></code></li><li id="type-value.VBool" class="def variant constructor anchored"><a href="#type-value.VBool" class="anchor"></a><code><span>| </span><span><span class="constructor">VBool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-value.VFloat" class="def variant constructor anchored"><a href="#type-value.VFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">VFloat</span> <span class="keyword">of</span> float</span></code></li><li id="type-value.VString" class="def variant constructor anchored"><a href="#type-value.VString" class="anchor"></a><code><span>| </span><span><span class="constructor">VString</span> <span class="keyword">of</span> string</span></code></li><li id="type-value.VVariant" class="def variant constructor anchored"><a href="#type-value.VVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">VVariant</span> <span class="keyword">of</span> string * <span><a href="#type-value">value</a> list</span></span></code></li><li id="type-value.VRecord" class="def variant constructor anchored"><a href="#type-value.VRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">VRecord</span> <span class="keyword">of</span> <span><span>(string, <a href="#type-value">value</a>)</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span></span></code></li><li id="type-value.VArray" class="def variant constructor anchored"><a href="#type-value.VArray" class="anchor"></a><code><span>| </span><span><span class="constructor">VArray</span> <span class="keyword">of</span> <span><a href="#type-value">value</a> array</span></span></code></li><li id="type-value.VRef" class="def variant constructor anchored"><a href="#type-value.VRef" class="anchor"></a><code><span>| </span><span><span class="constructor">VRef</span> <span class="keyword">of</span> <span><a href="#type-value">value</a> <span class="xref-unresolved">Core</span>.ref</span></span></code></li><li id="type-value.VClosure" class="def variant constructor anchored"><a href="#type-value.VClosure" class="anchor"></a><code><span>| </span><span><span class="constructor">VClosure</span> <span class="keyword">of</span> <a href="#type-clos">clos</a></span></code></li><li id="type-value.VModule" class="def variant constructor anchored"><a href="#type-value.VModule" class="anchor"></a><code><span>| </span><span><span class="constructor">VModule</span> <span class="keyword">of</span> <a href="#type-env">env</a></span></code></li><li id="type-value.VUnit" class="def variant constructor anchored"><a href="#type-value.VUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">VUnit</span></span></code></li><li id="type-value.VBuiltin" class="def variant constructor anchored"><a href="#type-value.VBuiltin" class="anchor"></a><code><span>| </span><span><span class="constructor">VBuiltin</span> <span class="keyword">of</span> <span><span><a href="#type-value">value</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-value">value</a></span></code></li></ol></div></div><p>Runtime values. Except for <code>VBuiltin</code>, every constructor is produced by executing ChatML code. <code>VBuiltin</code> wraps a host‚Äêimplemented OCaml function and is used to expose primitive operations and the standard library to user programs.</p><div class="odoc-spec"><div class="spec type anchored" id="type-clos"><a href="#type-clos" class="anchor"></a><code><span><span class="keyword">and</span> clos</span><span> = </span><span>{</span></code><ol><li id="type-clos.params" class="def record field anchored"><a href="#type-clos.params" class="anchor"></a><code><span>params : <span>string list</span>;</span></code></li><li id="type-clos.body" class="def record field anchored"><a href="#type-clos.body" class="anchor"></a><code><span>body : <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>;</span></code></li><li id="type-clos.env" class="def record field anchored"><a href="#type-clos.env" class="anchor"></a><code><span>env : <a href="#type-env">env</a>;</span></code></li><li id="type-clos.frames" class="def record field anchored"><a href="#type-clos.frames" class="anchor"></a><code><span>frames : <a href="../Frame_env/index.html#type-env">Frame_env.env</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>captured stack of frames at the lambda creation point</p><span class="comment-delim">*)</span></div></li><li id="type-clos.param_slots" class="def record field anchored"><a href="#type-clos.param_slots" class="anchor"></a><code><span>param_slots : <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>static slot layout for parameters</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-env"><a href="#type-env" class="anchor"></a><code><span><span class="keyword">and</span> env</span><span> = <span><span>(string, <a href="#type-value">value</a>)</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_env"><a href="#val-create_env" class="anchor"></a><code><span><span class="keyword">val</span> create_env : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-env">env</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy_env"><a href="#val-copy_env" class="anchor"></a><code><span><span class="keyword">val</span> copy_env : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-env">env</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_var"><a href="#val-find_var" class="anchor"></a><code><span><span class="keyword">val</span> find_var : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-value">value</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_var"><a href="#val-set_var" class="anchor"></a><code><span><span class="keyword">val</span> set_var : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-match_pattern"><a href="#val-match_pattern" class="anchor"></a><code><span><span class="keyword">val</span> match_pattern : <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <a href="#type-value">value</a>)</span> list</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collect_pattern_vars"><a href="#val-collect_pattern_vars" class="anchor"></a><code><span><span class="keyword">val</span> collect_pattern_vars : <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-eval_result"><a href="#type-eval_result" class="anchor"></a><code><span><span class="keyword">type</span> eval_result</span><span> = </span></code><ol><li id="type-eval_result.Value" class="def variant constructor anchored"><a href="#type-eval_result.Value" class="anchor"></a><code><span>| </span><span><span class="constructor">Value</span> <span class="keyword">of</span> <a href="#type-value">value</a></span></code></li><li id="type-eval_result.TailCall" class="def variant constructor anchored"><a href="#type-eval_result.TailCall" class="anchor"></a><code><span>| </span><span><span class="constructor">TailCall</span> <span class="keyword">of</span> <a href="#type-clos">clos</a> * <span><a href="#type-value">value</a> list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slot_of_expr"><a href="#val-slot_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> slot_of_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slot_of_value"><a href="#val-slot_of_value" class="anchor"></a><code><span><span class="keyword">val</span> slot_of_value : <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slot_matches_value"><a href="#val-slot_matches_value" class="anchor"></a><code><span><span class="keyword">val</span> slot_matches_value : <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_with_slot"><a href="#val-store_with_slot" class="anchor"></a><code><span><span class="keyword">val</span> store_with_slot : 
  <span><a href="../Frame_env/index.html#type-frame">Frame_env.frame</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-frames_nth"><a href="#val-frames_nth" class="anchor"></a><code><span><span class="keyword">val</span> frames_nth : <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Frame_env/index.html#type-frame">Frame_env.frame</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load_from_frames"><a href="#val-load_from_frames" class="anchor"></a><code><span><span class="keyword">val</span> load_from_frames : <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-var_loc">var_loc</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-value">value</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finish_eval"><a href="#val-finish_eval" class="anchor"></a><code><span><span class="keyword">val</span> finish_eval : <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-eval_result">eval_result</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-value">value</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_expr"><a href="#val-eval_expr" class="anchor"></a><code><span><span class="keyword">val</span> eval_expr : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-eval_result">eval_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-match_eval"><a href="#val-match_eval" class="anchor"></a><code><span><span class="keyword">val</span> match_eval : 
  <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-pattern">pattern</a> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-eval_result">eval_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-match_eval_slots"><a href="#val-match_eval_slots" class="anchor"></a><code><span><span class="keyword">val</span> match_eval_slots : 
  <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-pattern">pattern</a> * <span><a href="../Frame_env/index.html#type-packed_slot">Frame_env.packed_slot</a> list</span> * <span><a href="#type-expr">expr</a> <a href="#type-node">node</a></span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-eval_result">eval_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_stmt"><a href="#val-eval_stmt" class="anchor"></a><code><span><span class="keyword">val</span> eval_stmt : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Frame_env/index.html#type-env">Frame_env.env</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-stmt">stmt</a> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_program"><a href="#val-eval_program" class="anchor"></a><code><span><span class="keyword">val</span> eval_program : <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-program">program</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>eval_program env (stmts, module_name)</code> interprets a ChatML module.</p><p>The function mutates <code>env</code> in-place, inserting every value declared in the module at top-level. Evaluation proceeds in declaration order and uses an empty frame stack ‚Äì the interpreter never pushes frames for the toplevel, therefore side-effects visible outside the call happen solely through <code>env</code>.</p><p>Example executing a minimal program that prints <em>42</em> using a builtin <code>{!Chatml_builtin_modules.print_int}</code>:</p><pre class="language-ocaml"><code>  let open Chatochat.Chatml in
  let env = Chatml_lang.create_env () in
  (* Register primitives *)
  Hashtbl.set env ~key:&quot;print_int&quot; ~data:(VBuiltin (function
    | [ VInt n ] -&gt; print_endline (Int.to_string n); VUnit
    | _ -&gt; failwith &quot;invalid call&quot;));

  let prog : Chatml_lang.program =
    ( [ { Chatml_lang.value = Chatml_lang.SExpr
            ( { value = Chatml_lang.EApp
                ( { value = Chatml_lang.EVar &quot;print_int&quot;; span = Source.dummy }
                , [ { value = Chatml_lang.EInt 42; span = Source.dummy } ] )
            ; span = Source.dummy } )
        ; span = Source.dummy }
      ]
    , &quot;Main&quot; )
  in
  Chatml_lang.eval_program env prog</code></pre><p>After the call, the program has printed <code>42</code> and <code>env</code> contains the bindings introduced by the program (none in this example).</p></div></div></div></body></html>
