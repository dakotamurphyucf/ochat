<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Frame_env (ochat.Chatml.Frame_env)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Chatml</a> &#x00BB; Frame_env</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chatml.Frame_env</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#slot-descriptor">Slot descriptor</a></li><li><a href="#frame-allocation">Frame allocation</a></li><li><a href="#slot-access">Slot access</a></li><li><a href="#variable-descriptors">Variable descriptors</a></li><li><a href="#example">Example</a></li></ul></nav></div><div class="odoc-content"><p>Runtime environment for the ChatML interpreter/compiler.</p><p>A <code>frame</code> is a fixed-size array of <code>Obj.t</code> slots that stores the run-time values of variables that are in scope simultaneously. A stack of such frames â€“ the <code>env</code> â€“ represents nested scopes produced by `let`, function calls and module boundaries while executing ChatML programs.</p><p>The design goals are:</p><ul><li>Constant-time random access by index (arrays).</li><li>Compact, GC-friendly representation (uniform <code>Obj.t</code>).</li><li>Extensibility â€“ adding a new primitive type should be a compile-time change (GADT ensures exhaustiveness).</li></ul><p>The module exposes three layers of API:</p><h2 id="slot-descriptor"><a href="#slot-descriptor" class="anchor"></a>Slot descriptor</h2><p>A GADT <code>('a slot)</code> tags each position with the concrete OCaml type stored there (e.g. <code>SInt</code> for <code>int</code>). This information is erased at run-time but retained at the type level so that reads/writes remain type-safe without dynamic checks.</p><h2 id="frame-allocation"><a href="#frame-allocation" class="anchor"></a>Frame allocation</h2><p><a href="#val-alloc"><code>alloc</code></a> and <a href="#val-alloc_packed"><code>alloc_packed</code></a> create fresh frames from a layout description.</p><h2 id="slot-access"><a href="#slot-access" class="anchor"></a>Slot access</h2><p><a href="#val-set"><code>set</code></a> and <a href="#val-get"><code>get</code></a> are the *only* functions that use <code>Obj.magic</code>. Every other helper (e.g. <a href="#val-get_int"><code>get_int</code></a>) is a thin wrapper that specialises the slot type.</p><h2 id="variable-descriptors"><a href="#variable-descriptors" class="anchor"></a>Variable descriptors</h2><p><code>('a location)</code> describes where a variable lives at run-time: how many frames to pop (<code>depth</code>), the index inside that frame, and the slot kind. <a href="#val-load"><code>load</code></a> and <a href="#val-store"><code>store</code></a> follow the chain of frames to read or write a value.</p><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><pre class="language-ocaml"><code>  open Chatml.Frame_env

  let () =
    (* Build a frame layout *)
    let layout : _ slot list = [ SInt; SFloat ] in
    let fr = alloc layout in
    set_int fr 0 42;
    set_float fr 1 3.14;
    assert (get_int fr 0 = 42);
    assert (Float.equal (get_float fr 1) 3.14)</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-slot"><a href="#type-slot" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ slot</span></span><span> = </span></code><ol><li id="type-slot.SInt" class="def variant constructor anchored"><a href="#type-slot.SInt" class="anchor"></a><code><span>| </span><span><span class="constructor">SInt</span> : <span>int <a href="#type-slot">slot</a></span></span></code></li><li id="type-slot.SBool" class="def variant constructor anchored"><a href="#type-slot.SBool" class="anchor"></a><code><span>| </span><span><span class="constructor">SBool</span> : <span>bool <a href="#type-slot">slot</a></span></span></code></li><li id="type-slot.SFloat" class="def variant constructor anchored"><a href="#type-slot.SFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">SFloat</span> : <span>float <a href="#type-slot">slot</a></span></span></code></li><li id="type-slot.SString" class="def variant constructor anchored"><a href="#type-slot.SString" class="anchor"></a><code><span>| </span><span><span class="constructor">SString</span> : <span>string <a href="#type-slot">slot</a></span></span></code></li><li id="type-slot.SObj" class="def variant constructor anchored"><a href="#type-slot.SObj" class="anchor"></a><code><span>| </span><span><span class="constructor">SObj</span> : <span><span class="xref-unresolved">Stdlib</span>.Obj.t <a href="#type-slot">slot</a></span></span></code></li></ol></div><div class="spec-doc"><p>Slot descriptor â€“ compile-time tag of the OCaml type stored in a cell. The constructor name also doubles as the *run-time layout* information of the frame hence it must stay in sync with the way we serialise/deserialise values in <a href="#val-set"><code>set</code></a> and <a href="#val-get"><code>get</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_slot"><a href="#val-sexp_of_slot" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_slot : 
  'a__001_. <span><span>(<span><span class="type-var">'a__001_</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a__001_</span> <a href="#type-slot">slot</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-packed_slot"><a href="#type-packed_slot" class="anchor"></a><code><span><span class="keyword">type</span> packed_slot</span><span> = </span></code><ol><li id="type-packed_slot.Slot" class="def variant constructor anchored"><a href="#type-packed_slot.Slot" class="anchor"></a><code><span>| </span><span><span class="constructor">Slot</span> : <span><span class="type-var">'a</span> <a href="#type-slot">slot</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-packed_slot">packed_slot</a></span></code></li></ol></div><div class="spec-doc"><p>Existential wrapper used when the precise type of the slot is not known statically (e.g. when assembling heterogeneous lists). All constructors have the same run-time representation so the wrapper merely hides the type parameter.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_packed_slot"><a href="#val-sexp_of_packed_slot" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_packed_slot : <span><a href="#type-packed_slot">packed_slot</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-frame"><a href="#type-frame" class="anchor"></a><code><span><span class="keyword">type</span> frame</span><span> = <span><span class="xref-unresolved">Stdlib</span>.Obj.t array</span></span></code></div><div class="spec-doc"><p>Mutable block of storage for one scope. Indexing is O(1). The representation uses a uniform <code>Obj.t</code> array so that immediates and heap pointers coexist.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-env"><a href="#type-env" class="anchor"></a><code><span><span class="keyword">type</span> env</span><span> = <span><a href="#type-frame">frame</a> list</span></span></code></div><div class="spec-doc"><p>A stack of frames â€“ innermost scope at the head.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc"><a href="#val-alloc" class="anchor"></a><code><span><span class="keyword">val</span> alloc : <span><span><span><span class="type-var">'a</span> <a href="#type-slot">slot</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-frame">frame</a></span></code></div><div class="spec-doc"><p><code>alloc layout</code> returns a fresh frame whose size equals <code>List.length layout</code>. All cells are initialised to the immediate <code>0</code> which is a valid bit-pattern for every slot constructor. The caller is expected to populate each cell before reading it.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">layout</span> <p>ordered list describing the *physical* layout of the frame. The order must match the indexing decisions taken by the resolver.</p></li></ul><p>Example allocating a 3-slot frame:</p><pre class="language-ocaml"><code>  let fr = alloc [ SInt; SBool; SString ] in
  assert (Array.length fr = 3)</code></pre></div></div><p><code>alloc_packed layout</code> â€“ convenience wrapper that takes a list of <code>packed_slot</code> (heterogeneous) instead of a homogeneous <code>'a slot list</code> and returns a fresh frame. At the moment the GC representation of every slot constructor is identical â€“ an <code>Obj.t</code> pointer or immediate â€“ therefore we can safely ignore the *precise* slot type when allocating. The function exists purely so that higher-level passes (resolver / interpreter) do *not* have to coerce their heterogeneous <code>packed_slot list</code> into a fake homogeneous list just to satisfy the type checker.</p><p>As soon as we upgrade the runtime to allocate *fully* typed frames (e.g. using custom C blocks or unboxed float arrays) this helper will need to be revisited â€“ its implementation, not its interface.</p><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_packed"><a href="#val-alloc_packed" class="anchor"></a><code><span><span class="keyword">val</span> alloc_packed : <span><span><a href="#type-packed_slot">packed_slot</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-frame">frame</a></span></code></div><div class="spec-doc"><p><code>alloc_packed layout</code> is the existentially-typed variant of <a href="#val-alloc"><code>alloc</code></a> whose <code>layout</code> comes as a heterogeneous list of <code>packed_slot</code>. The current implementation ignores the precise slot type because every constructor maps to the same run-time representation. This may change in future versions once frames become more strongly typed.</p><p>It exists purely for ergonomic reasons in passes where the layout is discovered dynamically (e.g. the resolver).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : 'a. <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-slot">slot</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set frame slot idx v</code> writes <code>v</code> into <code>frame.(idx)</code>. The caller must supply the same <code>slot</code> tag that was used during layout construction; otherwise undefined behaviour may follow. No bounds checks are performed â€“ the resolver is responsible for generating valid indices.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : 'a. <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-slot">slot</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get frame slot idx</code> returns the value stored at <code>frame.(idx)</code> cast back to the appropriate ML type as indicated by <code>slot</code>. The function uses <code>Obj.magic</code> internally but remains type-safe at the call-site thanks to the GADT witness.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_int"><a href="#val-get_int" class="anchor"></a><code><span><span class="keyword">val</span> get_int : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Convenience wrappers that specialise <a href="#val-get"><code>get</code></a>/<a href="#val-set"><code>set</code></a> for each slot constructor. They remove the need to repeat the slot witness at every call-site.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_int"><a href="#val-set_int" class="anchor"></a><code><span><span class="keyword">val</span> set_int : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_bool"><a href="#val-get_bool" class="anchor"></a><code><span><span class="keyword">val</span> get_bool : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_bool"><a href="#val-set_bool" class="anchor"></a><code><span><span class="keyword">val</span> set_bool : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_float"><a href="#val-get_float" class="anchor"></a><code><span><span class="keyword">val</span> get_float : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> float</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_float"><a href="#val-set_float" class="anchor"></a><code><span><span class="keyword">val</span> set_float : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_str"><a href="#val-get_str" class="anchor"></a><code><span><span class="keyword">val</span> get_str : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_str"><a href="#val-set_str" class="anchor"></a><code><span><span class="keyword">val</span> set_str : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_obj"><a href="#val-get_obj" class="anchor"></a><code><span><span class="keyword">val</span> get_obj : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Obj.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_obj"><a href="#val-set_obj" class="anchor"></a><code><span><span class="keyword">val</span> set_obj : <span><a href="#type-frame">frame</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Obj.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-location"><a href="#type-location" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a location</span></span><span> = </span><span>{</span></code><ol><li id="type-location.depth" class="def record field anchored"><a href="#type-location.depth" class="anchor"></a><code><span>depth : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>How many frames to pop before the variable's frame.</p><span class="comment-delim">*)</span></div></li><li id="type-location.index" class="def record field anchored"><a href="#type-location.index" class="anchor"></a><code><span>index : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Zero-based offset inside that frame.</p><span class="comment-delim">*)</span></div></li><li id="type-location.slot" class="def record field anchored"><a href="#type-location.slot" class="anchor"></a><code><span>slot : <span><span class="type-var">'a</span> <a href="#type-slot">slot</a></span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Slot descriptor used to cast the value safely.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Descriptor that pinpoints a variable's storage location at run-time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load"><a href="#val-load" class="anchor"></a><code><span><span class="keyword">val</span> load : 'a. <span><span><span class="type-var">'a</span> <a href="#type-location">location</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>load loc env</code> traverses <code>env</code> by popping <code>loc.depth</code> frames and returns the value stored at <code>loc.index</code> in that frame.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if the environment is shallower than <code>loc.depth</code> (internal invariant violation).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store"><a href="#val-store" class="anchor"></a><code><span><span class="keyword">val</span> store : 'a. <span><span><span class="type-var">'a</span> <a href="#type-location">location</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-env">env</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>store loc env v</code> writes <code>v</code> to the slot referenced by <code>loc</code> inside <code>env</code>. The traversal logic mirrors <a href="#val-load"><code>load</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if the environment is shallower than <code>loc.depth</code>.</p></li></ul></div></div></div></body></html>
