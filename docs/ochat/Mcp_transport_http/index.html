<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mcp_transport_http (ochat.Mcp_transport_http)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Mcp_transport_http</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Mcp_transport_http</span></code></h1><p>HTTP/‚ÄãHTTPS transport for the *Model-Context-Protocol*.</p><p>Implements <a href="../Mcp_transport_interface/module-type-TRANSPORT/index.html"><code>Mcp_transport_interface.TRANSPORT</code></a> on top of <code>Piaf</code>, <code>Eio</code> and the ‚ÄúStreamable-HTTP‚Äù flavour of the MCP wire protocol (revision&amp;nbsp;2025-03-26).</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#supported-content-types">Supported content-types</a></li><li><a href="#authentication-workflow">Authentication workflow</a></li><li><a href="#session-persistence">Session persistence</a></li><li><a href="#uri-schemes">URI schemes</a></li><li><a href="#concurrency-semantics">Concurrency semantics</a></li><li><a href="#exception-connection_closed">Exception <code>Connection_closed</code></a></li></ul></nav></div><div class="odoc-content"><h2 id="supported-content-types"><a href="#supported-content-types" class="anchor"></a>Supported content-types</h2><p>‚Ä¢ <code>application/json</code> ‚Äì the response body is parsed once and all JSON values are enqueued immediately. This is used for *single-shot* requests such as <code>&quot;model.list&quot;</code>.</p><p>‚Ä¢ <code>text/event-stream</code> ‚Äì the body is treated as a **Server-Sent Events (SSE)** stream. A dedicated fibre decodes events line-by-line and enqueues each JSON payload as soon as it arrives. The transport drops the special ‚Äú<code>DONE</code>‚Äù message used by some servers to mark the end of a stream.</p><h2 id="authentication-workflow"><a href="#authentication-workflow" class="anchor"></a>Authentication workflow</h2><p>When <code>?auth</code> (default) is enabled, <code>connect</code> performs a best-effort OAuth&amp;nbsp;2 flow:</p><ol><li>Credentials are located in the following order of precedence: explicit URI query parameters ‚Äì environment variables ‚Äì client-store ‚Äì dynamic client registration.</li><li>Once credentials are obtained, the transport fetches an access token from the issuer (= scheme + authority of the endpoint URI) and adds ‚ÄúAuthorization: Bearer ‚Ä¶‚Äù headers to every request.</li></ol><p>The helper functions live in <a href="../Oauth2_manager/index.html"><code>Oauth2_manager</code></a> and <a href="../Oauth2_http/index.html"><code>Oauth2_http</code></a>. Failures are logged to <code>stderr</code> and the connection falls back to anonymous mode.</p><h2 id="session-persistence"><a href="#session-persistence" class="anchor"></a>Session persistence</h2><p>The server can return an *Mcp-Session-Id* header. The transport stores the first value it sees and includes it in all subsequent requests so that the server can associate a series of HTTP requests with the same logical session.</p><h2 id="uri-schemes"><a href="#uri-schemes" class="anchor"></a>URI schemes</h2><p>‚Ä¢ ‚Äúhttp:‚Äù / ‚Äúmcp+http:‚Äù ‚Äî clear-text HTTP ‚Ä¢ ‚Äúhttps:‚Äù / ‚Äúmcp+https:‚Äù ‚Äî TLS-encrypted HTTP/2 or HTTP/1.1 (as negotiated by Piaf)</p><p>Any other scheme triggers <code>Invalid_argument</code> in <code>connect</code>.</p><h2 id="concurrency-semantics"><a href="#concurrency-semantics" class="anchor"></a>Concurrency semantics</h2><p>The implementation is **fully concurrent**: ‚Ä¢ <code>send</code> is non-blocking ‚Äì the JSON payload is handed to a background fibre that performs the actual POST so that callers do not stall. ‚Ä¢ <code>recv</code> blocks until a value is available. Multiple fibres can call <code>recv</code> concurrently; they will dequeue in FIFO order.</p><h2 id="exception-connection_closed"><a href="#exception-connection_closed" class="anchor"></a>Exception <code>Connection_closed</code></h2><p>Raised by any operation once the remote peer closed the TCP connection or after <code>close</code> has been called. In that state <code>is_closed</code> is <code>true</code> and further <code>send</code>/<code>recv</code> invocations re-raise the exception.</p><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Mcp_transport_interface/module-type-TRANSPORT/index.html">Mcp_transport_interface.TRANSPORT</a></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : 
  <span><span class="optlabel">?auth</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>connect ?auth ~sw ~env uri</code> returns a *live* handle linked to <code>sw</code>.</p><p>Required arguments ‚Ä¢ <code>sw</code> ‚Äì lifetime switch that bounds every resource allocated by the transport. When the switch finishes the implementation closes the connection automatically. ‚Ä¢ <code>env</code> ‚Äì <code>Eio_unix.Stdenv.base</code> giving access to the host‚Äôs process manager, network stack and entropy sources. ‚Ä¢ <code>uri</code> ‚Äì endpoint description. The scheme selects the concrete implementation, e.g. <code>&quot;stdio:&quot;</code>, <code>&quot;http:&quot;</code>, <code>&quot;https:&quot;</code>.</p><p>Optional arguments ‚Ä¢ <code>auth</code> ‚Äì enable implementation-specific authentication helpers (default = <code>true</code>). Ignored by the stdio transport; causes the HTTP variant to perform bearer-token OAuth 2.</p><p>Behaviour ‚Ä¢ Blocks until the connection is ready to exchange data. ‚Ä¢ Raises <code>Invalid_argument</code> if the scheme is unknown or if the attempt fails.</p><p>Performance is dominated by the network handshake or process-spawn latency, whichever applies.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-send"><a href="#val-send" class="anchor"></a><code><span><span class="keyword">val</span> send : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>send t msg</code> writes exactly one JSON value.</p><p>‚Ä¢ Serialises <code>msg</code> using <code>Jsonaf.to_string</code>; implementation-specific framing (newline, HTTP chunk, ‚Ä¶) is added afterwards. ‚Ä¢ Blocks until **all** bytes have been handed to the operating system or until the peer closes the connection. ‚Ä¢ Mutating <code>msg</code> after the call returns is safe; the transport keeps no reference.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Connection_closed"><code>Connection_closed</code></a> <p>If the underlying stream is closed.</p></li></ul><p>Performance: the stdio implementation is `O(length msg)` (single <code>Eio.Flow.copy_string</code>); other transports may buffer internally.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span><span class="keyword">val</span> recv : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Jsonaf</span>.t</span></code></div><div class="spec-doc"><p><code>recv t</code> returns the next JSON value emitted by the server.</p><p>‚Ä¢ Blocks until a *full* value has been decoded. ‚Ä¢ Values are delivered in FIFO order w.r.t. the wire.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Connection_closed"><code>Connection_closed</code></a> <p>If EOF is observed before a full value has arrived.</p></li></ul></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Connection_closed"><a href="#exception-Connection_closed" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Connection_closed</span></span></code></div><div class="spec-doc"><p>Raised by <a href="#val-send"><code>send</code></a> or <a href="#val-recv"><code>recv</code></a> if the underlying stream reached EOF or was closed explicitly. Clients can catch the exception and try to re-connect.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> is <code>true</code> after <a href="#val-close"><code>close</code></a> completes *or* after <code>Connection_closed</code> has been raised. The flag never toggles back to <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> shuts the connection down and frees resources.</p><p>Idempotent; concurrent or repeated invocations are allowed. After the function returns <a href="#val-is_closed"><code>is_closed</code></a> yields <code>true</code> and both <a href="#val-send"><code>send</code></a> and <a href="#val-recv"><code>recv</code></a> raise <code>Connection_closed</code>.</p></div></div></details></div></div></body></html>
