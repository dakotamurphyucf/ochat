<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tikitoken (ochat.Tikitoken)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Tikitoken</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Tikitoken</span></code></h1><p>Byte-pair encoder/decoder compatible with OpenAI's *tiktoken*.</p><p>The module offers a minimal OCaml implementation of the byte-pair encoding (BPE) vocabulary used by OpenAI models such as *ochat-3.5-turbo* and *ochat-4*. After initialising a <a href="#type-codec"><code>codec</code></a> with the contents of a `*.tiktoken` vocabulary file you can:</p><p>‚Ä¢ convert UTF-8 text to the list of integer token identifiers expected by the HTTP APIs (<a href="#val-encode"><code>encode</code></a>); ‚Ä¢ perform the inverse mapping (<a href="#val-decode"><code>decode</code></a>) ‚Äì useful for debugging and for estimating request sizes.</p><p>The implementation is</p><p>‚Ä¢ <b>pure</b>: all file I/O is left to the caller; ‚Ä¢ <b>dependency-light</b>: relies on `core`, `base64` and `pcre` only; ‚Ä¢ <b>faithful</b>: produces the same tokenisation as the reference Python library for the supported vocabularies.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#getting-started">Getting started</a></li></ul></nav></div><div class="odoc-content"><h2 id="getting-started"><a href="#getting-started" class="anchor"></a>Getting started</h2><pre class="language-ocaml"><code>  (* Load and initialise the vocabulary once *)
  let bpe   = In_channel.read_all &quot;./cl100k_base.tiktoken&quot; in
  let codec = Tikitoken.create_codec bpe in

  (* Count tokens of an arbitrary prompt *)
  let prompt = &quot;Hello üê´ world!&quot; in
  let ids    = Tikitoken.encode ~codec ~text:prompt in
  printf &quot;prompt length = %d tokens\n&quot; (List.length ids);

  (* Round-trip to verify the implementation *)
  assert (Bytes.to_string (Tikitoken.decode ~codec ~encoded:ids) = prompt);</code></pre><p>All public functions are allocation-friendly and run in the caller‚Äôs fibre ‚Äì they do not block or perform hidden I/O.</p><div class="odoc-spec"><div class="spec type anchored" id="type-codec"><a href="#type-codec" class="anchor"></a><code><span><span class="keyword">type</span> codec</span><span> = </span><span>{</span></code><ol><li id="type-codec.encoder" class="def record field anchored"><a href="#type-codec.encoder" class="anchor"></a><code><span>encoder : <span><span>(bytes, int)</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>maps byte sequences -&gt; token id</p><span class="comment-delim">*)</span></div></li><li id="type-codec.decoder" class="def record field anchored"><a href="#type-codec.decoder" class="anchor"></a><code><span>decoder : <span><span>(int, bytes)</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>inverse mapping</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Bidirectional BPE vocabulary ‚Äì a pair of hash tables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_codec"><a href="#val-create_codec" class="anchor"></a><code><span><span class="keyword">val</span> create_codec : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-codec">codec</a></span></code></div><div class="spec-doc"><p><code>create_codec contents</code> parses a `*.tiktoken` vocabulary and returns a ready-to-use <code>codec</code>.</p><p><code>contents</code> must follow the format used by the reference implementation: one entry per line, a Base64-encoded byte sequence followed by a single space and the integer rank, e.g.</p><pre>RGVm 12345</pre><p>The function runs in O(n) where n is the number of entries and stores the mappings in two hash tables for O(1) look-ups.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encode"><a href="#val-encode" class="anchor"></a><code><span><span class="keyword">val</span> encode : <span><span class="label">codec</span>:<a href="#type-codec">codec</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">text</span>:string <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p><code>encode ~codec ~text</code> splits <code>text</code> with the *tiktoken* regular expression and looks up every segment in <code>codec.encoder</code>. Segments missing from the vocabulary are recursively broken down with the byte-pair merge algorithm.</p><p>Returns the list of token identifiers encountered from left to right. The length of the result therefore equals the number of produced tokens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decode"><a href="#val-decode" class="anchor"></a><code><span><span class="keyword">val</span> decode : <span><span class="label">codec</span>:<a href="#type-codec">codec</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">encoded</span>:<span>int list</span> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>decode ~codec ~encoded</code> concatenates the byte sequences associated with the token identifiers in <code>encoded</code>.</p><p>Identifiers that are not present in the vocabulary are ignored and decoded as the empty string. The resulting buffer is returned as a mutable <code>bytes</code> value ‚Äì use <code>Bytes.to_string</code> if an immutable <code>string</code> is required.</p></div></div></div></body></html>
