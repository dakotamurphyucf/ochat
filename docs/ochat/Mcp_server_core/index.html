<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mcp_server_core (ochat.Mcp_server_core)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Mcp_server_core</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Mcp_server_core</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-JT"><a href="#module-JT" class="anchor"></a><code><span><span class="keyword">module</span> JT</span><span> = <a href="../Mcp_types/index.html">Mcp_types</a></span></code></div></div><p>In-memory registry shared by every runtime component of the MCP server.</p><p>The module is *transport-agnostic*: it contains no I/O, spawns no fibres and depends only on <code>Core</code>. HTTP and stdio transports interact with it exclusively through the functions below and by registering hook callbacks.</p><p>Responsibilities:</p><p>â€¢ **Tools** â€“ store an OCaml handler together with the tool metadata (<a href="../Mcp_types/Tool/index.html#type-t"><code>JT.Tool.t</code></a>). Re-registering the same <code>name</code> replaces the handler and fires the <code>tools-changed</code> hook so that transports can broadcast a <b>notifications/tools/list_changed</b> event.</p><p>â€¢ **Prompts** â€“ store named chat templates, represented as opaque JSON so transports can round-trip them losslessly.</p><p>â€¢ **Structured logging** â€“ forward arbitrary JSON log payloads to zero or more registered sinks.</p><p>â€¢ **Progress streaming** â€“ let long-running handlers report incremental status updates.</p><p>â€¢ **Cancellation** â€“ honour <b>notifications/cancelled</b> messages sent by clients.</p><p>All data lives in mutable hash tables that are safe under the standard single-domain OCaml runtime. If you compile the server for multiple domains, protect every mutating operation with a mutex.</p><div class="odoc-spec"><div class="spec type anchored" id="type-tool_handler"><a href="#type-tool_handler" class="anchor"></a><code><span><span class="keyword">type</span> tool_handler</span><span> = <span><span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="xref-unresolved">Jsonaf</span>.t, string)</span> <span class="xref-unresolved">Core</span>.Result.t</span></span></code></div><div class="spec-doc"><p>Handler type for executing a tool. Takes the JSON arguments sent in the <code>tools/call</code> request and returns either a JSON result (on success) or an error message string.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-prompt"><a href="#type-prompt" class="anchor"></a><code><span><span class="keyword">type</span> prompt</span><span> = </span><span>{</span></code><ol><li id="type-prompt.description" class="def record field anchored"><a href="#type-prompt.description" class="anchor"></a><code><span>description : <span>string option</span>;</span></code></li><li id="type-prompt.messages" class="def record field anchored"><a href="#type-prompt.messages" class="anchor"></a><code><span>messages : <span class="xref-unresolved">Jsonaf</span>.t;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A prompt as exposed by the server. The representation follows the MCP schema at a very high level â€“ for now we only need a textual description and the already-rendered chat messages that will be sent back to the client. The concrete JSON structure of <code>messages</code> is left entirely to the caller so that we can round-trip it without interpretation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-log_level"><a href="#type-log_level" class="anchor"></a><code><span><span class="keyword">type</span> log_level</span><span> = </span><span>[ </span></code><ol><li id="type-log_level.Debug" class="def variant constructor anchored"><a href="#type-log_level.Debug" class="anchor"></a><code><span>| </span><span>`Debug</span></code></li><li id="type-log_level.Info" class="def variant constructor anchored"><a href="#type-log_level.Info" class="anchor"></a><code><span>| </span><span>`Info</span></code></li><li id="type-log_level.Notice" class="def variant constructor anchored"><a href="#type-log_level.Notice" class="anchor"></a><code><span>| </span><span>`Notice</span></code></li><li id="type-log_level.Warning" class="def variant constructor anchored"><a href="#type-log_level.Warning" class="anchor"></a><code><span>| </span><span>`Warning</span></code></li><li id="type-log_level.Error" class="def variant constructor anchored"><a href="#type-log_level.Error" class="anchor"></a><code><span>| </span><span>`Error</span></code></li><li id="type-log_level.Critical" class="def variant constructor anchored"><a href="#type-log_level.Critical" class="anchor"></a><code><span>| </span><span>`Critical</span></code></li><li id="type-log_level.Alert" class="def variant constructor anchored"><a href="#type-log_level.Alert" class="anchor"></a><code><span>| </span><span>`Alert</span></code></li><li id="type-log_level.Emergency" class="def variant constructor anchored"><a href="#type-log_level.Emergency" class="anchor"></a><code><span>| </span><span>`Emergency</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log"><a href="#val-log" class="anchor"></a><code><span><span class="keyword">val</span> log : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">level</span>:<a href="#type-log_level">log_level</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?logger</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>log t ~level ?logger data</code> emits a structured log entry that is forwarded to every registered logging hook. <code>data</code> should be an arbitrary JSON object/value describing the event.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_logging_hook"><a href="#val-add_logging_hook" class="anchor"></a><code><span><span class="keyword">val</span> add_logging_hook : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="label">level</span>:<a href="#type-log_level">log_level</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">logger</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Register a callback that is invoked for each log event. The HTTP server uses this to broadcast <code>notifications/message</code> SSE events to clients.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-progress_payload"><a href="#type-progress_payload" class="anchor"></a><code><span><span class="keyword">type</span> progress_payload</span><span> = </span><span>{</span></code><ol><li id="type-progress_payload.progress_token" class="def record field anchored"><a href="#type-progress_payload.progress_token" class="anchor"></a><code><span>progress_token : string;</span></code></li><li id="type-progress_payload.progress" class="def record field anchored"><a href="#type-progress_payload.progress" class="anchor"></a><code><span>progress : float;</span></code></li><li id="type-progress_payload.total" class="def record field anchored"><a href="#type-progress_payload.total" class="anchor"></a><code><span>total : <span>float option</span>;</span></code></li><li id="type-progress_payload.message" class="def record field anchored"><a href="#type-progress_payload.message" class="anchor"></a><code><span>message : <span>string option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Structured payload for progress updates as per MCP <code>notifications/progress</code>. The <code>progress</code> field is a monotonically increasing value (typically 0â€“1 when <code>total</code> is omitted). When a concrete <code>total</code> is known the sender SHOULD supply it so that UIs can derive a percentage. The <code>message</code> is intended for human readable status updates (e.g. &quot;Reticulating splinesâ€¦&quot;).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_progress_hook"><a href="#val-add_progress_hook" class="anchor"></a><code><span><span class="keyword">val</span> add_progress_hook : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-progress_payload">progress_payload</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-notify_progress"><a href="#val-notify_progress" class="anchor"></a><code><span><span class="keyword">val</span> notify_progress : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-progress_payload">progress_payload</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel_request"><a href="#val-cancel_request" class="anchor"></a><code><span><span class="keyword">val</span> cancel_request : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">id</span>:<a href="../Mcp_types/Jsonrpc/Id/index.html#type-t">Mcp_types.Jsonrpc.Id.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Mark a request as cancelled. Servers invoke this from the router when a <code>notifications/cancelled</code> message is received.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_cancelled"><a href="#val-is_cancelled" class="anchor"></a><code><span><span class="keyword">val</span> is_cancelled : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">id</span>:<a href="../Mcp_types/Jsonrpc/Id/index.html#type-t">Mcp_types.Jsonrpc.Id.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Test whether a request has been cancelled. Long-running handlers can poll this cooperatively and abort early to free resources.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ()</code> returns a brand-new registry with no registered artefacts.</p><p>Under the current single-domain runtime the function is thread-safe â€“ all state is protected by the OCaml runtime lock. When running under a multi-domain runtime you <b>must</b> introduce external synchronisation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_tools_changed_hook"><a href="#val-add_tools_changed_hook" class="anchor"></a><code><span><span class="keyword">val</span> add_tools_changed_hook : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Hooks let the transport layer (e.g. the HTTP server) be informed when the list of tools or prompts changes so it can emit <code>notifications/*/list_changed</code> messages to connected clients.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_prompts_changed_hook"><a href="#val-add_prompts_changed_hook" class="anchor"></a><code><span><span class="keyword">val</span> add_prompts_changed_hook : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_resources_changed_hook"><a href="#val-add_resources_changed_hook" class="anchor"></a><code><span><span class="keyword">val</span> add_resources_changed_hook : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-notify_resources_changed"><a href="#val-notify_resources_changed" class="anchor"></a><code><span><span class="keyword">val</span> notify_resources_changed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-register_tool"><a href="#val-register_tool" class="anchor"></a><code><span><span class="keyword">val</span> register_tool : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Mcp_types/Tool/index.html#type-t">JT.Tool.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tool_handler">tool_handler</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>register_tool t spec handler</code> registers a new tool with metadata <code>spec</code> and an OCaml <code>handler</code> implementation. If another tool with the same name already exists it is silently replaced.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-register_prompt"><a href="#val-register_prompt" class="anchor"></a><code><span><span class="keyword">val</span> register_prompt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">name</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prompt">prompt</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>register_prompt t ~name prompt</code> registers a new named prompt. Any prompt previously stored under that <code>name</code> is replaced.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_tools"><a href="#val-list_tools" class="anchor"></a><code><span><span class="keyword">val</span> list_tools : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Mcp_types/Tool/index.html#type-t">JT.Tool.t</a> list</span></span></code></div><div class="spec-doc"><p><code>list_tools t</code> returns all known tools in undefined order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_tool"><a href="#val-get_tool" class="anchor"></a><code><span><span class="keyword">val</span> get_tool : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-tool_handler">tool_handler</a> * <a href="../Mcp_types/Tool/index.html#type-t">JT.Tool.t</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>get_tool t name</code> looks up <code>name</code> and returns both the metadata and the execution handler.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_prompts"><a href="#val-list_prompts" class="anchor"></a><code><span><span class="keyword">val</span> list_prompts : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(string * <a href="#type-prompt">prompt</a>)</span> list</span></span></code></div><div class="spec-doc"><p><code>list_prompts t</code> returns <code>(name, prompt)</code> pairs for all registered prompts in undefined order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_prompt"><a href="#val-get_prompt" class="anchor"></a><code><span><span class="keyword">val</span> get_prompt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prompt">prompt</a> option</span></span></code></div><div class="spec-doc"><p><code>get_prompt t name</code> fetches a single prompt by <code>name</code>.</p></div></div></div></body></html>
