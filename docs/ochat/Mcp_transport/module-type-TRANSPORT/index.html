<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TRANSPORT (ochat.Mcp_transport.TRANSPORT)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Mcp_transport</a> &#x00BB; TRANSPORT</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module type <code><span>Mcp_transport.TRANSPORT</span></code></h1><p>Opaque handle representing a *live* connection to exactly one MCP server. The concrete representation depends on the transport implementation and must not leak outside the module.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : 
  <span><span class="optlabel">?auth</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>connect ?auth ~sw ~env uri</code> returns a *live* handle linked to <code>sw</code>.</p><p>Required arguments â€¢ <code>sw</code> â€“ lifetime switch that bounds every resource allocated by the transport. When the switch finishes the implementation closes the connection automatically. â€¢ <code>env</code> â€“ <code>Eio_unix.Stdenv.base</code> giving access to the hostâ€™s process manager, network stack and entropy sources. â€¢ <code>uri</code> â€“ endpoint description. The scheme selects the concrete implementation, e.g. <code>&quot;stdio:&quot;</code>, <code>&quot;http:&quot;</code>, <code>&quot;https:&quot;</code>.</p><p>Optional arguments â€¢ <code>auth</code> â€“ enable implementation-specific authentication helpers (default = <code>true</code>). Ignored by the stdio transport; causes the HTTP variant to perform bearer-token OAuth 2.</p><p>Behaviour â€¢ Blocks until the connection is ready to exchange data. â€¢ Raises <code>Invalid_argument</code> if the scheme is unknown or if the attempt fails.</p><p>Performance is dominated by the network handshake or process-spawn latency, whichever applies.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-send"><a href="#val-send" class="anchor"></a><code><span><span class="keyword">val</span> send : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>send t msg</code> writes exactly one JSON value.</p><p>â€¢ Serialises <code>msg</code> using <code>Jsonaf.to_string</code>; implementation-specific framing (newline, HTTP chunk, â€¦) is added afterwards. â€¢ Blocks until **all** bytes have been handed to the operating system or until the peer closes the connection. â€¢ Mutating <code>msg</code> after the call returns is safe; the transport keeps no reference.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Connection_closed"><code>Connection_closed</code></a> <p>If the underlying stream is closed.</p></li></ul><p>Performance: the stdio implementation is `O(length msg)` (single <code>Eio.Flow.copy_string</code>); other transports may buffer internally.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span><span class="keyword">val</span> recv : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Jsonaf</span>.t</span></code></div><div class="spec-doc"><p><code>recv t</code> returns the next JSON value emitted by the server.</p><p>â€¢ Blocks until a *full* value has been decoded. â€¢ Values are delivered in FIFO order w.r.t. the wire.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Connection_closed"><code>Connection_closed</code></a> <p>If EOF is observed before a full value has arrived.</p></li></ul></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Connection_closed"><a href="#exception-Connection_closed" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Connection_closed</span></span></code></div><div class="spec-doc"><p>Raised by <a href="#val-send"><code>send</code></a> or <a href="#val-recv"><code>recv</code></a> if the underlying stream reached EOF or was closed explicitly. Clients can catch the exception and try to re-connect.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> is <code>true</code> after <a href="#val-close"><code>close</code></a> completes *or* after <code>Connection_closed</code> has been raised. The flag never toggles back to <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> shuts the connection down and frees resources.</p><p>Idempotent; concurrent or repeated invocations are allowed. After the function returns <a href="#val-is_closed"><code>is_closed</code></a> yields <code>true</code> and both <a href="#val-send"><code>send</code></a> and <a href="#val-recv"><code>recv</code></a> raise <code>Connection_closed</code>.</p></div></div></div></body></html>
