<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ocaml_parser (ochat.Ocaml_parser)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Ocaml_parser</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Ocaml_parser</span></code></h1><p>OCaml source‚Äêcode inspector.</p><p><em>Ocaml_parser</em> offers a minimal, effect-free API to lex, parse and traverse *.ml* / *.mli* files. The goal is to extract, for every top-level item, both its syntactical representation and the documentation comments attached to it. The resulting records are convenient building blocks for downstream consumers such as search indices, documentation generators, or chat-bot context windows.</p><p>A typical workflow is:</p><p>‚Ä¢ Use <a href="#val-collect_ocaml_files"><code>collect_ocaml_files</code></a> to discover OCaml files in a source tree. ‚Ä¢ Feed each <a href="#type-module_info"><code>module_info</code></a> to <a href="#val-parse_module_info"><code>parse_module_info</code></a>. The function returns <a href="#type-traverse_input"><code>traverse_input</code></a> thunks ‚Äì one for the implementation file, one for the interface ‚Äì so that the expensive lexing step can be isolated from the cheaper AST traversal. ‚Ä¢ Call <a href="#val-traverse"><code>traverse</code></a> on each input to obtain a list of <a href="#type-parse_result"><code>parse_result</code></a> describing every top-level binding.</p><p>Internally the module relies on <em>ppxlib</em>'s <code>Ppxlib.Parse</code> parser and <code>Ppxlib.Ast_traverse</code> visitors but all complexity is hidden behind the straightforward record types defined below.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-ocaml_source"><a href="#type-ocaml_source" class="anchor"></a><code><span><span class="keyword">type</span> ocaml_source</span><span> = </span></code><ol><li id="type-ocaml_source.Interface" class="def variant constructor anchored"><a href="#type-ocaml_source.Interface" class="anchor"></a><code><span>| </span><span><span class="constructor">Interface</span></span></code></li><li id="type-ocaml_source.Implementation" class="def variant constructor anchored"><a href="#type-ocaml_source.Implementation" class="anchor"></a><code><span>| </span><span><span class="constructor">Implementation</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Kind of OCaml source file: <code>.mli</code> interface or <code>.ml</code> implementation.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-parse_result"><a href="#type-parse_result" class="anchor"></a><code><span><span class="keyword">type</span> parse_result</span><span> = </span><span>{</span></code><ol><li id="type-parse_result.location" class="def record field anchored"><a href="#type-parse_result.location" class="anchor"></a><code><span>location : string;</span></code></li><li id="type-parse_result.file" class="def record field anchored"><a href="#type-parse_result.file" class="anchor"></a><code><span>file : string;</span></code></li><li id="type-parse_result.module_path" class="def record field anchored"><a href="#type-parse_result.module_path" class="anchor"></a><code><span>module_path : string;</span></code></li><li id="type-parse_result.comments" class="def record field anchored"><a href="#type-parse_result.comments" class="anchor"></a><code><span>comments : <span>string list</span>;</span></code></li><li id="type-parse_result.contents" class="def record field anchored"><a href="#type-parse_result.contents" class="anchor"></a><code><span>contents : string;</span></code></li><li id="type-parse_result.ocaml_source" class="def record field anchored"><a href="#type-parse_result.ocaml_source" class="anchor"></a><code><span>ocaml_source : <a href="#type-ocaml_source">ocaml_source</a>;</span></code></li><li id="type-parse_result.line_start" class="def record field anchored"><a href="#type-parse_result.line_start" class="anchor"></a><code><span>line_start : int;</span></code></li><li id="type-parse_result.char_start" class="def record field anchored"><a href="#type-parse_result.char_start" class="anchor"></a><code><span>char_start : int;</span></code></li><li id="type-parse_result.line_end" class="def record field anchored"><a href="#type-parse_result.line_end" class="anchor"></a><code><span>line_end : int;</span></code></li><li id="type-parse_result.char_end" class="def record field anchored"><a href="#type-parse_result.char_end" class="anchor"></a><code><span>char_end : int;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Metadata produced by <a href="#val-traverse"><code>traverse</code></a>. All offsets are 1-based and relative to the beginning of <code>file</code>.</p><p>‚Ä¢ <code>location</code> ‚Äì Human-readable ‚ÄúFile ‚Ä¶ line ‚Ä¶ character ‚Ä¶‚Äù string mirroring the compiler style. ‚Ä¢ <code>module_path</code> ‚Äì Dotted path of nested modules (e.g. &quot;Foo.Bar&quot;). ‚Ä¢ <code>comments</code> ‚Äì List of docstrings (`(** ‚Ä¶ *)`) associated with the item. ‚Ä¢ <code>contents</code> ‚Äì Raw source code snippet for the item. ‚Ä¢ <code>line_start</code>/<code>char_start</code>/<code>line_end</code>/<code>char_end</code> ‚Äì Precise span of <code>contents</code> inside <code>file</code>. ‚Ä¢ <code>ocaml_source</code> ‚Äì Whether the snippet comes from an interface or an implementation file.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-traverse_input"><a href="#type-traverse_input" class="anchor"></a><code><span><span class="keyword">type</span> traverse_input</span></code></div><div class="spec-doc"><p>Bundle of data required by <a href="#val-traverse"><code>traverse</code></a>. A value of this type is <b>not</b> expensive to allocate ‚Äì the heavyweight parsing work has already happened. See <a href="#val-parse"><code>parse</code></a> and <code>parse_file_info</code> for constructors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse"><a href="#val-traverse" class="anchor"></a><code><span><span class="keyword">val</span> traverse : <span><a href="#type-traverse_input">traverse_input</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-parse_result">parse_result</a> list</span></span></code></div><div class="spec-doc"><p><code>traverse input</code> walks the AST contained in <code>input</code> and returns every top-level binding as a <a href="#type-parse_result"><code>parse_result</code></a>.</p><p>The function is <em>deterministic</em> and does not allocate global resources ‚Äì it can safely be called in parallel across domains.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : 
  <span><span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-ocaml_source">ocaml_source</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-traverse_input">traverse_input</a></span></code></div><div class="spec-doc"><p><code>parse dir file kind module_name</code> lexes and parses <code>file</code> (looked up relative to <code>dir</code>), yielding a <a href="#type-traverse_input"><code>traverse_input</code></a> that can later be given to <a href="#val-traverse"><code>traverse</code></a>.</p><p>The function reads the whole file in memory ‚Äì callers should avoid feeding multi-megabyte artefacts.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-file_type"><a href="#type-file_type" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ file_type</span></span><span> = </span></code><ol><li id="type-file_type.Mli" class="def variant constructor anchored"><a href="#type-file_type.Mli" class="anchor"></a><code><span>| </span><span><span class="constructor">Mli</span> : <span><a href="#type-mli">mli</a> <a href="#type-file_type">file_type</a></span></span></code></li><li id="type-file_type.Ml" class="def variant constructor anchored"><a href="#type-file_type.Ml" class="anchor"></a><code><span>| </span><span><span class="constructor">Ml</span> : <span><a href="#type-ml">ml</a> <a href="#type-file_type">file_type</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mli"><a href="#type-mli" class="anchor"></a><code><span><span class="keyword">and</span> mli</span><span> = </span></code><ol><li id="type-mli.MLI" class="def variant constructor anchored"><a href="#type-mli.MLI" class="anchor"></a><code><span>| </span><span><span class="constructor">MLI</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ml"><a href="#type-ml" class="anchor"></a><code><span><span class="keyword">and</span> ml</span><span> = </span></code><ol><li id="type-ml.ML" class="def variant constructor anchored"><a href="#type-ml.ML" class="anchor"></a><code><span>| </span><span><span class="constructor">ML</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Phantom types used to tag interface / implementation files at the type level.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-file_info"><a href="#type-file_info" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a file_info</span></span><span> = </span><span>{</span></code><ol><li id="type-file_info.file_type" class="def record field anchored"><a href="#type-file_info.file_type" class="anchor"></a><code><span>file_type : <span><span class="type-var">'a</span> <a href="#type-file_type">file_type</a></span>;</span></code></li><li id="type-file_info.file_name" class="def record field anchored"><a href="#type-file_info.file_name" class="anchor"></a><code><span>file_name : string;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A source file bundled with its kind at the type level.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-module_info"><a href="#type-module_info" class="anchor"></a><code><span><span class="keyword">type</span> module_info</span><span> = </span><span>{</span></code><ol><li id="type-module_info.mli_file" class="def record field anchored"><a href="#type-module_info.mli_file" class="anchor"></a><code><span>mli_file : <span><span><a href="#type-mli">mli</a> <a href="#type-file_info">file_info</a></span> option</span>;</span></code></li><li id="type-module_info.ml_file" class="def record field anchored"><a href="#type-module_info.ml_file" class="anchor"></a><code><span>ml_file : <span><span><a href="#type-ml">ml</a> <a href="#type-file_info">file_info</a></span> option</span>;</span></code></li><li id="type-module_info.module_path" class="def record field anchored"><a href="#type-module_info.module_path" class="anchor"></a><code><span>module_path : string;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>All the files backing a single compilation unit.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_module_info"><a href="#val-parse_module_info" class="anchor"></a><code><span><span class="keyword">val</span> parse_module_info : 
  <span><span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-module_info">module_info</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-traverse_input">traverse_input</a> option</span> * <span><a href="#type-traverse_input">traverse_input</a> option</span></span></code></div><div class="spec-doc"><p><code>parse_module_info dir t</code> parses <code>t.ml</code> and/or <code>t.mli</code> (when present) and returns a pair of optional <a href="#type-traverse_input"><code>traverse_input</code></a>. The parsing step is performed immediately so that the returned thunks are cheap to compute in parallel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collect_ocaml_files"><a href="#val-collect_ocaml_files" class="anchor"></a><code><span><span class="keyword">val</span> collect_ocaml_files : 
  <span><span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-module_info">module_info</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>collect_ocaml_files dir subdir</code> recursively explores <code>subdir</code> and returns metadata for every module found (.ml / .mli files).</p><p>The traversal continues in sub-directories that are not OCaml source files. Errors (permission denied, broken symlinks‚Ä¶) are turned into <code>Error msg</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-format_parse_result"><a href="#val-format_parse_result" class="anchor"></a><code><span><span class="keyword">val</span> format_parse_result : <span><a href="#type-parse_result">parse_result</a> <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>format_parse_result parse_result</code> formats the given <code>parse_result</code> into a string.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">parse_result</span> <p>The parse result to be formatted.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>A formatted string containing the parse result information.</p></li></ul><p><code>format_parse_result r</code> converts <code>r</code> into a pair <code>(header, body)</code> ready to be saved to disk or passed to downstream systems. <code>header</code> contains metadata in an OCaml comment while <code>body</code> concatenates the original doc-comments and code snippet.</p></div></div></div></body></html>
