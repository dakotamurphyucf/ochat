<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Renderer (ochat.Chat_tui.Renderer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Chat_tui</a> &#x00BB; Renderer</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chat_tui.Renderer</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-render_full"><a href="#val-render_full" class="anchor"></a><code><span><span class="keyword">val</span> render_full : <span><span class="label">size</span>:<span>(int * int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">model</span>:<a href="../Model/index.html#type-t">Model.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Notty</span>.I.t * <span>(int * int)</span></span></code></div><div class="spec-doc"><p>Full-screen renderer for the terminal chat UI.</p><p><code>Chat_tui.Renderer</code> turns the current <a href="../Model/index.html#type-t"><code>Chat_tui.Model.t</code></a> into a composite <code>Notty.I.t</code> image plus a caret position for the input box. It acts as the &quot;view&quot; in the TUI architecture: it reads the model and terminal size and leaves input handling and state updates to <a href="../Controller/index.html"><code>Chat_tui.Controller</code></a> and <a href="../App/index.html"><code>Chat_tui.App</code></a>.</p><p>Layout</p><p>The screen is laid out top-to-bottom as:</p><ul><li>a virtualised, scrollable history viewport backed by a <a href="../../Notty_scroll_box/index.html#type-t"><code>Notty_scroll_box.t</code></a>;</li><li>optionally, a one-row sticky header (when there is enough vertical space) that repeats the role header of the first fully visible message;</li><li>a one-line mode / status bar;</li><li>a framed, multi-line input box.</li></ul><p>State and caching</p><p>Rendering is pure with respect to the outside world (no I/O), but the renderer does mutate a few cache fields inside <code>model</code> as part of its contract:</p><ul><li>per-message render cache and cached height / prefix-sum arrays used for scroll virtualisation;</li><li>the scroll box stored in <code>model</code>, updated to honour <a href="../Model/index.html#type-t.auto_follow"><code>Chat_tui.Model.t.auto_follow</code></a> and to clamp the scroll offset to the valid range for the current viewport height.</li></ul><p>Text handling and highlighting</p><ul><li>Message bodies are sanitised with <a href="../Util/index.html#val-sanitize"><code>Chat_tui.Util.sanitize</code></a> <code>~strip:false</code> so that <code>Notty.I.string</code> never sees control characters; newlines are preserved.</li><li>Fenced code blocks delimited by three backticks or three tildes are detected via <a href="../Markdown_fences/index.html#val-split"><code>Chat_tui.Markdown_fences.split</code></a>. Non-HTML blocks are highlighted with <a href="../Highlight_tm_engine/index.html"><code>Chat_tui.Highlight_tm_engine</code></a> configured with the shared registry from <a href="../Highlight_registry/index.html"><code>Chat_tui.Highlight_registry</code></a>.</li><li><p>Messages classified as tool output via <a href="../Model/index.html#type-t.tool_output_by_index"><code>Chat_tui.Model.t.tool_output_by_index</code></a> and <a href="../Types/index.html#type-tool_output_kind"><code>Chat_tui.Types.tool_output_kind</code></a> may be rendered with specialised layouts. For example:</p><ul><li><code>Apply_patch</code> output splits into a status preamble and a patch section highlighted using the internal <code>&quot;ochat-apply-patch&quot;</code> grammar.</li><li><code>Read_file { path }</code> output may infer a syntax-highlighting language via <a href="#val-lang_of_path"><code>lang_of_path</code></a>. Markdown files are rendered using the normal Markdown pipeline (including fence splitting) so that fenced code blocks can be highlighted by their own info strings.</li><li><code>Read_directory</code> output is tinted to distinguish it from prose.</li></ul></li><li>Non-code paragraphs are highlighted as markdown when a grammar is available. When markdown highlighting falls back to plain text, a small <code>&quot;**bold**&quot;</code> / <code>&quot;__bold__&quot;</code> heuristic is used to preserve emphasis in common cases.</li></ul><p>Each non-empty message is preceded by a header row that shows an icon and the capitalised role label (for example <code>&quot;assistant&quot;</code>, <code>&quot;user&quot;</code>, <code>&quot;tool&quot;</code>). The message body does not include an inline <code>&quot;role:&quot;</code> prefix so that copying terminal selections yields clean snippets.</p><p>Cursor position</p><p>The cursor coordinates returned by <a href="#val-render_full"><code>render_full</code></a> are absolute screen coordinates suitable for <code>Notty_unix.Term.cursor</code> and <a href="../../Notty_eio/Term/index.html#val-cursor"><code>Notty_eio.Term.cursor</code></a>.</p><p><b>Limitation:</b> the caret position is derived from byte offsets in the input buffer. With multi-byte UTF-8 and East-Asian wide glyphs, the cursor may not line up with the displayed text.</p><p><code>render_full ~size ~model</code> builds the full screen image and the cursor position.</p><ul><li><code>size</code> is <code>(width, height)</code> in terminal cells;</li><li><code>model</code> is the current UI state (messages, input buffer, selection, scroll box, modes, etc.).</li></ul><p>The result is <code>(image, (cx, cy))</code> where <code>image</code> is the composite screen and <code>(cx, cy)</code> is the caret position inside the input box in absolute cell coordinates with <code>(0, 0)</code> at the top-left corner of the terminal.</p><p><code>render_full</code> updates renderer caches inside <code>model</code> (message image cache, cached heights/prefix sums, and the embedded scroll box) to make subsequent renders cheaper.</p><p>Behaviour</p><ul><li>the history viewport renders only those messages that can become visible in a <code>height</code>-row window and pads with transparent rows above and below so that its logical height matches the full transcript;</li><li>per-message render results are cached in <code>model</code> keyed by terminal width and message text; when the width changes, the cache and prefix-sum arrays are rebuilt;</li><li>when <code>Chat_tui.Model.auto_follow model</code> is <code>true</code>, the history view scrolls to the bottom after updating its content image; otherwise the existing scroll offset stored in the model's <a href="../../Notty_scroll_box/index.html#type-t"><code>Notty_scroll_box.t</code></a> is respected.</li></ul><p>Example â€“ integrate into a Notty event loop:</p><pre class="language-ocaml"><code>  let render term model =
    let w, h = Notty_eio.Term.size term in
    let image, (cx, cy) = Chat_tui.Renderer.render_full ~size:(w, h) ~model in
    Notty_eio.Term.image term image;
    Notty_eio.Term.cursor term (Some (cx, cy))
  in
  ()</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lang_of_path"><a href="#val-lang_of_path" class="anchor"></a><code><span><span class="keyword">val</span> lang_of_path : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>lang_of_path path</code> performs best-effort language inference for <code>read_file</code> tool outputs.</p><p>The helper inspects the file extension of <code>path</code> and returns a TextMate-style language identifier when known. For example:</p><ul><li><code>&quot;.ml&quot;</code> and <code>&quot;.mli&quot;</code> map to <code>&quot;ocaml&quot;</code>;</li><li><code>&quot;.md&quot;</code> maps to <code>&quot;markdown&quot;</code>;</li><li><code>&quot;.json&quot;</code> maps to <code>&quot;json&quot;</code>;</li><li><code>&quot;.sh&quot;</code> maps to <code>&quot;bash&quot;</code>.</li></ul><p>Paths without an extension and unrecognised extensions yield <code>None</code>. The function is exposed primarily for unit tests and debugging of the renderer's tool-output handling.</p></div></div></div></body></html>
