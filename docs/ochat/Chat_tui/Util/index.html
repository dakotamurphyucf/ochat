<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Util (ochat.Chat_tui.Util)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Chat_tui</a> &#x00BB; Util</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ğŸ” Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chat_tui.Util</span></code></h1><p>Pure helper helpers for the text-based user-interface.</p><p>All functions in this module are:</p><p>â€¢ Fully <em>side-effect free</em> â€“ they do not mutate global state, perform I/O or rely on wall-clock time. â€¢ Small, single-purpose utilities that are shared by various Chat-TUI sub-modules.</p><p>The helpers focus on preparing arbitrary user-supplied strings for safe terminal output: sanitising control characters, truncating overly long messages and wrapping UTF-8 input into slices that respect a byte budget.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#functions">Functions</a></li></ul></nav></div><div class="odoc-content"><h2 id="functions"><a href="#functions" class="anchor"></a>Functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-sanitize"><a href="#val-sanitize" class="anchor"></a><code><span><span class="keyword">val</span> sanitize : <span><span class="optlabel">?strip</span>:bool <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sanitize ?strip s</code> returns <code>s</code> with every ASCII control character â€“ all bytes in the ranges <code>[\x00â€“\x1F]</code> and <code>[\x7F]</code> â€“ replaced by a space.</p><p>Special-cases: â€¢ TAB characters are expanded to four spaces. â€¢ NEWLINE (<code>\n</code>) is preserved so the caller can keep intentional line breaks.</p><p>When <code>?strip</code> (defaults to <code>true</code>) the result is additionally trimmed with <code>Core.String.strip</code>. In particular, leading and trailing newlines that survived the replacement step are removed.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">strip</span> <p>whether to apply <code>Core.String.strip</code> (default <code>true</code>)</p></li></ul><p>Sanitising a string that contains a bell (<code>\007</code>) and a tab:</p><pre class="language-ocaml"><code> let clean = Chat_tui.Util.sanitize &quot;be\007\tboop&quot; in
   assert (String.equal clean &quot;be    boop&quot;) </code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncate"><a href="#val-truncate" class="anchor"></a><code><span><span class="keyword">val</span> truncate : <span><span class="optlabel">?max_len</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>truncate ?max_len s</code> cuts <code>s</code> to at most <code>max_len</code> bytes. If the limit is hit, the Unicode ellipsis character (&quot;â€¦&quot;, U+2026) is appended so the caller can tell that data was lost.</p><p>The function always calls <code>Core.String.strip</code> first so whitespace at the boundaries does not count towards the budget.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_len</span> <p>maximum number of bytes to preserve from <code>s</code> (default 300)</p></li></ul><p>Keeping only the first 5 visible bytes:</p><pre class="language-ocaml"><code>  let s = Chat_tui.Util.truncate ~max_len:5 &quot;  abcdefg&quot; in
  assert (String.equal s &quot;abcdeâ€¦&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrap_line"><a href="#val-wrap_line" class="anchor"></a><code><span><span class="keyword">val</span> wrap_line : <span><span class="label">limit</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>wrap_line ~limit s</code> splits <code>s</code> into chunks with a maximum <em>byte</em> length of <code>limit</code>. Splits <b>never</b> occur in the middle of a multi-byte UTF-8 scalar value; every element of the returned list is therefore valid UTF-8 in isolation.</p><p>The byte budget is a pragmatic choice: we use it because the downstream rendering layer (Notty text widgets) counts one code-point per byte and we are primarily interested in avoiding very large allocations when dealing with streamed assistant responses.</p><p>The function does <i>not</i> try to honour grapheme clusters nor display-width (East-Asian wide glyphs are still counted as one unit) â€“ callers that need a more sophisticated layout strategy must post-process the result.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>never â€“ malformed UTF-8 is tolerated; bytes that do not fit the official prefix patterns are treated as single-byte code-points to guarantee progress.</p></li></ul><p>Splitting a multi-byte string into 4-byte slices:</p><pre class="language-ocaml"><code>  let parts = Chat_tui.Util.wrap_line ~limit:4 &quot;ğŸ‘ğŸ‘ğŸ‘&quot; in
  (* Each ğŸ‘ is four bytes in UTF-8 *)
  assert (parts = [&quot;ğŸ‘&quot;; &quot;ğŸ‘&quot;; &quot;ğŸ‘&quot;])</code></pre></div></div></div></body></html>
