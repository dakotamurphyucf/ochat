<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Markdown_fences (ochat.Chat_tui.Markdown_fences)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Chat_tui</a> &#x00BB; Markdown_fences</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chat_tui.Markdown_fences</span></code></h1><p>Parse fenced code blocks and inline code spans from markdown-like text.</p><p>The module provides two small, allocation-friendly utilities:</p><ul><li><code>split</code> separates a string into block-level segments, recognizing fenced code blocks delimited by exactly three backticks (```) or three tildes (~~~).</li><li><code>split_inline</code> scans a single line for inline code spans delimited by single backticks.</li></ul><p>The parsers are intentionally conservative and designed for rendering in the TUI rather than full markdown compliance. See the function docs for invariants and known limitations.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-segment"><a href="#type-segment" class="anchor"></a><code><span><span class="keyword">type</span> segment</span><span> = </span></code><ol><li id="type-segment.Text" class="def variant constructor anchored"><a href="#type-segment.Text" class="anchor"></a><code><span>| </span><span><span class="constructor">Text</span> <span class="keyword">of</span> string</span></code></li><li id="type-segment.Code_block" class="def variant constructor anchored"><a href="#type-segment.Code_block" class="anchor"></a><code><span>| </span><span><span class="constructor">Code_block</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-segment.lang" class="def record field anchored"><a href="#type-segment.lang" class="anchor"></a><code><span>lang : <span>string option</span>;</span></code></li><li id="type-segment.code" class="def record field anchored"><a href="#type-segment.code" class="anchor"></a><code><span>code : string;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>Block-level segment produced by <a href="#val-split"><code>split</code></a>.</p><ul><li><code>Text s</code> is a contiguous region of non-code text. Newlines inside <code>s</code> are preserved.</li><li><code>Code_block { lang; code }</code> is the body captured between a matching opening and closing fence. <code>lang</code> is the first non-empty token that follows the opening fence on the same line (e.g. <code>&quot;ocaml&quot;</code> for <code>```ocaml</code>), or <code>None</code> if absent. <code>code</code> contains the lines strictly between the fences, without the fence markers themselves.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-segment">segment</a> list</span></span></code></div><div class="spec-doc"><p><code>split s</code> partitions <code>s</code> into text and fenced code blocks.</p><p>Recognizes a fence only if it appears at the start of a line, optionally preceded by up to three spaces, and consists of exactly three identical characters chosen from backtick (`) or tilde (~). The closing fence must use the same character and length.</p><p>The optional language/info string is parsed as the first non-empty token after the opening fence and exposed as <code>lang</code>. Any remaining characters on the fence line are ignored.</p><ul><li>Unclosed blocks: if the input ends while inside a fence, the entire unterminated region (including the opening fence line) is returned as a single <code>Text</code> segment.</li><li>Newlines: segment boundaries always occur on line boundaries; newlines in <code>Text</code> and <code>Code_block.code</code> are preserved as in the input.</li></ul><p>Limitations:</p><ul><li>Only exactly three backticks or three tildes are treated as fences; more than three are not recognized.</li><li>Tabs before the fence are not treated as indentation; only spaces count toward the ‚Äúup to three leading spaces‚Äù rule.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inline"><a href="#type-inline" class="anchor"></a><code><span><span class="keyword">type</span> inline</span><span> = </span></code><ol><li id="type-inline.Inline_text" class="def variant constructor anchored"><a href="#type-inline.Inline_text" class="anchor"></a><code><span>| </span><span><span class="constructor">Inline_text</span> <span class="keyword">of</span> string</span></code></li><li id="type-inline.Inline_code" class="def variant constructor anchored"><a href="#type-inline.Inline_code" class="anchor"></a><code><span>| </span><span><span class="constructor">Inline_code</span> <span class="keyword">of</span> string</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_inline"><a href="#val-split_inline" class="anchor"></a><code><span><span class="keyword">val</span> split_inline : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-inline">inline</a> list</span></span></code></div><div class="spec-doc"><p><code>split_inline s</code> scans <code>s</code> for inline code spans delimited by backticks and returns an alternating sequence of <code>Inline_text</code> and <code>Inline_code</code>.</p><p>Behaviour and limitations:</p><ul><li>Backtick runs of length <code>n &gt;= 1</code> are recognized, and a code span is formed by the next run with at least <code>n</code> consecutive backticks. (Only <code>n</code> backticks are consumed as the delimiter; any remaining backticks are treated as normal text.)</li><li>A backtick preceded by a backslash is treated as a literal character and does not start or end a code span.</li><li>Nesting is not supported.</li><li>If a closing delimiter is missing, the opening delimiter is treated as plain text (it is not dropped).</li></ul></div></div></div></body></html>
