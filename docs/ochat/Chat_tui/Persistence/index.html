<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Persistence (ochat.Chat_tui.Persistence)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ochat</a> &#x00BB; <a href="../index.html">Chat_tui</a> &#x00BB; Persistence</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chat_tui.Persistence</span></code></h1><p>Persistence helpers for ChatMarkdown transcripts.</p><p>This module is responsible for keeping the *disk* representation of a chat session in sync with the in-memory conversation state. All file I/O â€“ writing user input, appending assistant responses, and off-loading bulky tool call payloads â€“ funnels through the two functions below. The helper sticks to the <span class="xref-unresolved" title="Eio">Eio</span> capability style: callers must pass an explicit directory capability instead of relying on ambient authority.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-write_user_message"><a href="#val-write_user_message" class="anchor"></a><code><span><span class="keyword">val</span> write_user_message : 
  <span><span class="label">dir</span>:<span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">file</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>write_user_message ~dir ~file msg</code> updates the *last* <code>`&lt;user&gt;`</code> element of the ChatMarkdown document <code>file</code>.</p><p>If the transcript already ends with an <i>empty</i> user stub â€“ the pattern shown below â€“ the stub is **replaced** in-place:</p><pre>&lt;user&gt;

&lt;/user&gt;</pre><p>Otherwise the function simply *appends* a new block at EOF. In both cases the written XML fragment follows exactly this layout (final newline included):</p><pre>&lt;user&gt;
$msg
&lt;/user&gt;</pre><p>where <code>$msg</code> is the verbatim content of <code>msg</code>. The helper never strips or escapes the text â€“ callers are expected to sanitise user input up-front if necessary.</p><p>The operation is atomic with respect to the underlying <code>Eio.Path</code> flow returned by <code>Eio.Path.with_open_out</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-persist_session"><a href="#val-persist_session" class="anchor"></a><code><span><span class="keyword">val</span> persist_session : 
  <span><span class="label">dir</span>:<span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">prompt_file</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">datadir</span>:<span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cfg</span>:<a href="../../Chat_response/Config/index.html#type-t">Chat_response.Config.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">initial_msg_count</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">history_items</span>:<span><a href="../../Openai/Responses/Item/index.html#type-t">Openai.Responses.Item.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>persist_session ~dir ~prompt_file ~datadir ~cfg ~initial_msg_count ~history_items</code> appends every *new* item in <code>history_items</code> to the transcript file <code>prompt_file</code> located under <code>dir</code>.</p><p>&quot;New&quot; means entries whose list index is <code>&gt;=</code> <code>initial_msg_count</code>. Earlier items are assumed to be already present on disk.</p><p>Serialisation rules</p><p>â€¢ *User / assistant / tool* messages become their corresponding ChatMarkdown blocks (`&lt;user&gt;â€¦`, `&lt;assistant&gt;â€¦`, `&lt;tool_response&gt;â€¦`).</p><p>â€¢ *Function / tool calls* (variants <a href="../../Openai/Responses/Item/index.html#type-t.Function_call"><code>Openai.Responses.Item.t.Function_call</code></a> and <a href="../../Openai/Responses/Item/index.html#type-t.Function_call_output"><code>Openai.Responses.Item.t.Function_call_output</code></a>) are handled in two mutually exclusive ways depending on <code>cfg.show_tool_call</code>:</p><p>â€“ When <code>true</code>, the full JSON arguments / result is embedded inline between `RAW|` pipes so human readers can expand the details without leaving the file.</p><p>â€“ When <code>false</code> (the default) the payload is stored in a separate file `<code>N</code>.<code>call_id</code>.json` inside <code>datadir</code> â€“ typically <code>$HOME/.chatmd</code> â€“ and referenced through a `&lt;doc src=&quot;./.chatmd/...&quot;`&gt; tag. This keeps the main transcript readable even when the tool exchanges multi-kilobyte JSON blobs.</p><p>â€¢ *Reasoning summaries* become `&lt;reasoning&gt;` blocks with nested `&lt;summary&gt;` children.</p><p>The helper is <b>append-only</b>: it never rewrites or deletes existing data and therefore preserves the original chronological order of the conversation.</p><p>Example</p><pre class="language-ocaml"><code>  (* Append assistant response and tool output to the transcript. *)
  Chat_tui.Persistence.persist_session
    ~dir:(Eio.Stdenv.cwd env)
    ~prompt_file:&quot;prompt.chatmd&quot;
    ~datadir:(Io.ensure_chatmd_dir ~cwd:(Eio.Stdenv.cwd env))
    ~cfg
    ~initial_msg_count:List.length already_serialised
    ~history_items:new_history</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">cfg</span> <p>The active configuration record controlling formatting choices. Only <code>show_tool_call</code> is inspected.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>Never â€“ errors are reported synchronously via the Eio exception hierarchy.</p></li></ul></div></div></div></body></html>
