<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Oauth2_pkce_flow (ochat.Oauth2_pkce_flow)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Oauth2_pkce_flow</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Oauth2_pkce_flow</span></code></h1><p>OAuth 2.0 <em>Authorization Code</em> flow with <b>Proof-Key for Code Exchange (PKCE)</b> helper.</p><p>This module is tailored for <i>native</i> or command-line applications that cannot listen on public ports. It automates the common pattern:</p><p>1. Spins up a <b>one-shot HTTP listener</b> on <code>http://127.0.0.1:8876/cb</code>. 2. Generates a fresh PKCE <code>code_verifier</code> / <code>code_challenge</code> pair using <a href="../Oauth2_pkce/index.html#val-gen_code_verifier"><code>Oauth2_pkce.gen_code_verifier</code></a>. 3. Launches the userâ€™s browser at the authorisation endpoint with all required query parameters. 4. Waits for the authorisation server to redirect back with the <code>code</code> and returns it to the caller together with the <code>code_verifier</code> and <code>redirect_uri</code>.</p><p>A second helper <a href="#val-exchange_token"><code>exchange_token</code></a> subsequently exchanges the returned code for an access / refresh token.</p><p>The implementation relies solely on <code>Eio</code> for concurrency and networking; no web-framework is pulled in.</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="https://datatracker.ietf.org/doc/html/rfc7636" class="value">https://datatracker.ietf.org/doc/html/rfc7636</a> <p>RFC&amp;nbsp;7636 â€“ Proof-Key for Code Exchange</p></li></ul><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1" class="value">https://datatracker.ietf.org/doc/html/rfc6749#section-4.1</a> <p>RFC&amp;nbsp;6749 Â§4.1 â€“ Authorisation Code grant</p></li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-T"><a href="#module-T" class="anchor"></a><code><span><span class="keyword">module</span> T</span><span> = <a href="../Oauth2_types/index.html">Oauth2_types</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Result"><a href="#module-Result" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Result/index.html">Result</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_browser"><a href="#val-open_browser" class="anchor"></a><code><span><span class="keyword">val</span> open_browser : 
  <span><span class="label">env</span>:<span>&lt; process_mgr : <span><span>[&gt; <span><span>[&gt; `Generic ]</span> <span class="xref-unresolved">Eio</span>.Process.mgr_ty</span> ]</span> <span class="xref-unresolved">Eio</span>.Process.mgr</span>.. &gt;</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>open_browser ~env url</code> opens <code>url</code> in the userâ€™s default browser.</p><p>The helper is <b>best-effort</b>: on Unix it tries <em>xdg-open</em>, falling back to macOSâ€™ <code>open</code> command; on Windows it uses <code>start</code>. All failures are silently ignored because they are non-critical â€“ the user can always copy&amp;paste the URL.</p><p>Browser spawning is <b>skipped automatically</b> when either the <code>CI</code> or <code>OAUTH_NO_BROWSER</code> environment variable is present. This avoids hanging continuous-integration jobs and permits headless testing.</p><p>The function is intended for interactive use and therefore lives in this moduleâ€™s implementation only; applications should not rely on it directly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="label">env</span>:
    <span>&lt; net : <span><span>[&gt; <span><span class="type-var">'a</span> <span class="xref-unresolved">Eio</span>.Net.ty</span> ]</span> <span class="xref-unresolved">Eio__</span>.Std.r</span>
      ; process_mgr : <span><span>[&gt; <span><span>[&gt; `Generic ]</span> <span class="xref-unresolved">Eio</span>.Process.mgr_ty</span> ]</span> <span class="xref-unresolved">Eio</span>.Process.mgr</span>.. &gt;</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio__</span>.Std.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">meta</span>:<a href="../Oauth2_types/Metadata/index.html#type-t">T.Metadata.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">client_id</span>:string <span class="arrow">&#45;&gt;</span></span>
  string * string * string</span></code></div><div class="spec-doc"><p><code>run ~env ~sw ~meta ~client_id</code> initiates the interactive PKCE flow.</p><p>It blocks until the resource owner completes authentication and consent in the browser and the authorisation server redirects back to <code>http://127.0.0.1:8876/cb?code=â€¦</code>.</p><p>Returned triple:</p><ul><li><code>code</code> â€“ the single-use authorisation code (RFC&amp;nbsp;6749 Â§4.1.2).</li><li><code>verifier</code> â€“ the PKCE *code_verifier* generated for the request; pass it verbatim to <a href="#val-exchange_token"><code>exchange_token</code></a>.</li><li><code>redirect_uri</code> â€“ the exact redirect URI used (constant <code>`http://127.0.0.1:8876/cb`</code> at the moment).</li></ul><p>Notes &amp; invariants</p><ul><li>A dedicated TCP listener is created with <code>Eio.Net.listen ~reuse_addr:true ~reuse_port:true</code> and limited backlog <code>1</code>. Only the first successful callback is handled.</li><li>The port is currently fixed at <code>8876</code> to keep the registered redirect URI stable. Future revisions may randomise it.</li><li>The helper runs inside the supplied switch <code>sw</code>; callers must ensure <code>sw</code> remains alive until the function returns.</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">env</span> <p>The standard environment obtained from <code>Eio_main.run</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">sw</span> <p>Switch delimiting the lifetime of spawned fibers and socket listener.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">meta</span> <p>Service discovery metadata (see <a href="../Oauth2_types/Metadata/index.html"><code>Oauth2_types.Metadata</code></a>).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">client_id</span> <p>Public OAuth 2.0 client identifier.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Eio.Io</code> <p>on network errors while opening the browser or binding the TCP listener.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if JSON parsing of the redirect payload fails (should never happen under compliant servers).</p></li></ul><p>Example â€“ obtain an authorisation code</p><pre class="language-ocaml"><code>  Eio_main.run @@ fun env -&gt;
    Eio.Switch.run @@ fun sw -&gt;
      let code, verifier, redirect_uri =
        Oauth2_pkce_flow.run
          ~env ~sw
          ~meta
          ~client_id:&quot;my-native-app&quot;
      in
      Format.printf &quot;Auth code = %s@.&quot; code</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exchange_token"><a href="#val-exchange_token" class="anchor"></a><code><span><span class="keyword">val</span> exchange_token : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">meta</span>:<a href="../Oauth2_types/Metadata/index.html#type-t">T.Metadata.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">client_id</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">code</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">code_verifier</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">redirect_uri</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Oauth2_types/Token/index.html#type-t">T.Token.t</a>, string)</span> <a href="Result/index.html#type-t">Result.t</a></span></span></code></div><div class="spec-doc"><p><code>exchange_token ~env ~sw ~meta ~client_id ~code ~code_verifier ~redirect_uri</code> swaps the single-use <code>code</code> obtained from <a href="#val-run"><code>run</code></a> for an access token.</p><p>The helper performs a `POST` with a `application/x-www-form-urlencoded` body (grant = `authorization_code`) against the <code>meta.token_endpoint</code> and decodes the JSON response into an <a href="../Oauth2_types/Token/index.html#type-t"><code>Oauth2_types.Token.t</code></a> record.</p><p>The <code>`obtained_at`</code> field is stamped with the current <code>`Eio.Time.now`</code> so that <a href="../Oauth2_types/Token/index.html#val-is_expired"><code>Oauth2_types.Token.is_expired</code></a> works reliably.</p><p>Returns <code>`Ok tok`</code> on success or <code>`Error msg`</code> describing the failure (network/TLS error, HTTP â‰  2xx, JSON decoding problem).</p><p><b>Performance</b>: the function delegates to <a href="../Oauth2_http/index.html#val-post_form"><code>Oauth2_http.post_form</code></a> which uses a <i>one-shot</i> connection â€“ each call establishes and tears down a fresh TLS session. This is perfectly adequate for the sporadic traffic produced by OAuth clients.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Jsonaf.Parse_error</code> <p>Transparently propagated if the server returns invalid JSON (mirrors <a href="../Oauth2_http/index.html#val-post_form"><code>Oauth2_http.post_form</code></a> semantics).</p></li></ul><p>Example â€“ fully automated code exchange</p><pre class="language-ocaml"><code>  match
    Oauth2_pkce_flow.exchange_token
      ~env ~sw ~meta ~client_id
      ~code
      ~code_verifier:verifier
      ~redirect_uri
  with
  | Error msg -&gt; Format.eprintf &quot;Token error: %s@.&quot; msg
  | Ok tok    -&gt; Format.printf &quot;Access token = %s@.&quot; tok.access_token</code></pre></div></div></div></body></html>
