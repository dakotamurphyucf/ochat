<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Source (ochat.Source)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Source</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Source</span></code></h1><p>Source code helper utilities.</p><p>This module models a *source document* (typically the contents of a file) together with convenient helpers to query individual characters or extract substrings based on *spans* â€“ explicit left/right positions inside the text. It is designed to be the minimal dependency for lexers, parsers and type-checkers that need to keep track of locations for error reporting.</p><p>A span is represented by a pair of absolute positions (<code>left</code> and <code>right</code>) expressed in **bytes** counted from the start of the document. A <code>position</code> also stores the corresponding (1-based) line and column numbers so that clients can render human-friendly messages. Invariants:</p><p>â€¢ <code>offset</code> is in the range <code>0, Source.length src) where [src] is the parent document. â€¢ For any span [sp], [sp.left.offset &lt;= sp.right.offset].  The implementation does *not* enforce these invariants at construction time; it is the responsibility of the caller to supply consistent data. All helpers are **pure** â€“ they never mutate the underlying string â€“ and run in *O(1)* or *O(length)* where length is the size of the returned fragment. </code></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#types">Types</a></li><li><a href="#types_2">Types</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#accessors">Accessors</a></li><li><a href="#span-helpers">Span helpers</a></li></ul></nav></div><div class="odoc-content"><h2 id="types"><a href="#types" class="anchor"></a>Types</h2><h2 id="types_2"><a href="#types_2" class="anchor"></a>Types</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> </span><span>{</span></code><ol><li id="type-t.path" class="def record field anchored"><a href="#type-t.path" class="anchor"></a><code><span>path : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Absolute or relative path of the originating file if available. <code>None</code> for in-memory sources created with <a href="#val-make"><code>make</code></a>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.content" class="def record field anchored"><a href="#type-t.content" class="anchor"></a><code><span>content : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Full contents of the document.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A complete source document.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-position"><a href="#type-position" class="anchor"></a><code><span><span class="keyword">and</span> position</span><span> = </span><span>{</span></code><ol><li id="type-position.line" class="def record field anchored"><a href="#type-position.line" class="anchor"></a><code><span>line : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>1-based line number (\&gt;= 1).</p><span class="comment-delim">*)</span></div></li><li id="type-position.column" class="def record field anchored"><a href="#type-position.column" class="anchor"></a><code><span>column : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>0-based column within <code>line</code>. Tab expansion is caller defined â€“ this module does not normalise tabs.</p><span class="comment-delim">*)</span></div></li><li id="type-position.offset" class="def record field anchored"><a href="#type-position.offset" class="anchor"></a><code><span>offset : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Absolute byte offset from the start of <code>content</code>.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Absolute position inside a source document.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-span"><a href="#type-span" class="anchor"></a><code><span><span class="keyword">and</span> span</span><span> = </span><span>{</span></code><ol><li id="type-span.left" class="def record field anchored"><a href="#type-span.left" class="anchor"></a><code><span>left : <a href="#type-position">position</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inclusive left bound.</p><span class="comment-delim">*)</span></div></li><li id="type-span.right" class="def record field anchored"><a href="#type-span.right" class="anchor"></a><code><span>right : <a href="#type-position">position</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Exclusive right bound.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p><code>left, right) half-open interval inside a document. </code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_position"><a href="#val-sexp_of_position" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_position : <span><a href="#type-position">position</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_span"><a href="#val-sexp_of_span" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_span : <span><a href="#type-span">span</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> t_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-position_of_sexp"><a href="#val-position_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> position_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-position">position</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-span_of_sexp"><a href="#val-span_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> span_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-span">span</a></span></code></div></div><h2 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h2><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make contents</code> builds an in-memory source document with the given <code>contents</code>. <code>path</code> is set to <code>None</code>.</p><p>Example creating a source from a string:</p><pre class="language-ocaml"><code>  let src = Source.make &quot;hello&quot; in
  Source.length src = 5</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_file"><a href="#val-from_file" class="anchor"></a><code><span><span class="keyword">val</span> from_file : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>from_file filename</code> reads the whole file <code>filename</code> into memory and returns a corresponding source document. The <code>path</code> field of the result is <code>Some filename</code>. The file is read with <code>Stdlib.In_channel.open_text</code>, hence it honours the current localeâ€™s newline conversion rules.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Sys_error</code> <p>if the file cannot be opened or read.</p></li></ul></div></div><h2 id="accessors"><a href="#accessors" class="anchor"></a>Accessors</h2><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Total number of characters (bytes) in the document. Runs in O(1).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-at"><a href="#val-at" class="anchor"></a><code><span><span class="keyword">val</span> at : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char option</span></span></code></div><div class="spec-doc"><p><code>at src offset</code> returns <code>Some c</code> where <code>c</code> is the character at absolute <code>offset</code> inside <code>src</code>, or <code>None</code> if <code>offset</code> is out of bounds.</p><p>Equivalent to</p><pre class="language-ocaml"><code>  if 0 &lt;= offset &amp;&amp; offset &lt; Source.length src then
    Some src.content.[offset]
  else None</code></pre><p>but without raising <code>Invalid_argument</code>. Runs in O(1).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-span">span</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>read src span</code> extracts the substring designated by <code>span</code> from <code>src</code>.</p><p>The function is forgiving: if <code>span</code> extends outside the document it is automatically clamped to </p><pre class="language-ocaml"><code>                         0, Source.length src)}.  Therefore it never
raises beyond the usual out-of-memory errors.

Complexity is O(n) where n is the length of the returned substring. </code></pre></div></div><h2 id="span-helpers"><a href="#span-helpers" class="anchor"></a>Span helpers</h2><div class="odoc-spec"><div class="spec value anchored" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><a href="#type-span">span</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-span">span</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-span">span</a></span></code></div><div class="spec-doc"><p><code>merge sp1 sp2</code> returns the smallest span that contains both <code>sp1</code> and <code>sp2</code>. Its left bound is <code>sp1.left</code> and its right bound is <code>sp2.right</code>. The caller must guarantee that <code>sp1</code> lies entirely *before* <code>sp2</code>; the behaviour is undefined otherwise.</p></div></div></div></body></html>
