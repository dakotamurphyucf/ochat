<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Odoc_crawler (ochat.Odoc_crawler)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Odoc_crawler</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Odoc_crawler</span></code></h1><p>Traverse an <code>_odoc_</code> HTML documentation tree and present each document as Markdown.</p><p>The directory layout produced by the <code>`odoc`</code><code>https://github.com/ocaml/odoc</code> documentation generator looks like this (simplified):</p><pre>_build/default/_doc/_html/
â”œâ”€ core/
â”‚  â”œâ”€ Core/
â”‚  â”‚  â”œâ”€ Array.html
â”‚  â”‚  â””â”€ â€¦
â”‚  â””â”€ _doc-dir/README.md          &lt;- optional package README
â”œâ”€ eio/
â”‚  â””â”€ â€¦
â””â”€ index.html</pre><p>Each *package* gets its own top-level directory (e.g. <code>core</code> or <code>eio</code>). Inside the package directory every module is rendered as an HTML file and there may also be a <code>_doc-dir_</code> sub-directory that contains the packageâ€™s README in Markdown.</p><p><code>Odoc_crawler</code> walks such a tree concurrently and, for every relevant document encountered, converts it to Markdown (using <a href="../Webpage_markdown/Html_to_md/index.html"><code>Webpage_markdown.Html_to_md</code></a>) and forwards the result to a user-supplied callback. Hidden modules (those whose generated HTML contains the sentinel string &quot;This module is hidden.&quot;) are skipped.</p><p>The crawler is resilient: unreadable paths, parser failures and other recoverable errors are logged with <a href="../Log/index.html#val-emit"><code>Log.emit</code></a> and ignored. The only unchecked exceptions that can escape are those raised by the callback itself.</p><p>Concurrency is provided by <code>Eio.Fiber.List.iter</code> with <code>~max_fibers = 25</code> â€“ at most 25 directory entries are processed at the same time per level.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#example">Example</a></li></ul></nav></div><div class="odoc-content"><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>Crawling the documentation produced by a local `dune build @doc` run:</p><pre class="language-ocaml"><code>ocaml]
  let () =
    Eio_main.run @@ fun env -&gt;
    let root = Eio.Path.(Eio.Stdenv.cwd env / &quot;_build/default/_doc/_html&quot;) in
    Odoc_crawler.crawl root ~f:(fun ~pkg ~doc_path ~markdown -&gt;
      Format.printf &quot;[%s] %s (chars: %d)\n%!&quot; pkg doc_path (String.length markdown))</code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-is_html_file"><a href="#val-is_html_file" class="anchor"></a><code><span><span class="keyword">val</span> is_html_file : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><p><code>is_html_file file</code> is <code>true</code> iff <code>file</code> ends with the <code>.html</code> extension. The check is case-sensitive â€“ the odoc generator only emits lowercase extensions.</p><div class="odoc-spec"><div class="spec value anchored" id="val-is_readme_md"><a href="#val-is_readme_md" class="anchor"></a><code><span><span class="keyword">val</span> is_readme_md : <span><span class="xref-unresolved">Core</span>.String.t <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><p><code>is_readme_md file</code> recognises package README files inside an <code>_doc-dir</code> folder. The test is case-insensitive and matches both the bare name <code>README</code> as well as any file whose basename starts with <code>README.</code>, e.g. <code>README.md</code> or <code>ReadMe.markdown</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-read_file_to_string"><a href="#val-read_file_to_string" class="anchor"></a><code><span><span class="keyword">val</span> read_file_to_string : <span><span><span>[&gt; <span class="xref-unresolved">Eio__</span>.Fs.dir_ty ]</span> <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><p><code>read_file_to_string path</code> loads the entire file <code>path</code> into memory and returns it as a single string.</p><p>The implementation relies on <code>Eio.Buf_read.parse_exn</code> with the <code>Eio.Buf_read.take_all</code> parser and therefore honours the reader limits enforced by that module. In practice odoc-generated HTML files are small (around 5 MB), so the limit of <code>Int.max_value</code> is safe. The function never blocks the scheduler for long: IO is handled by <code>Eio.Switch.run</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-markdown_of_html"><a href="#val-markdown_of_html" class="anchor"></a><code><span><span class="keyword">val</span> markdown_of_html : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><p><code>markdown_of_html html</code> converts <code>html</code> (produced by odoc) to GitHub-flavour Markdown. Conversion uses <a href="../Webpage_markdown/Html_to_md/index.html#val-to_markdown_string"><code>Webpage_markdown.Html_to_md.to_markdown_string</code></a> which internally parses the markup with <code>Soup.parse</code>.</p><p>If the HTML is ill-formed or the converter raises for any reason the raw HTML is returned verbatim, fenced inside a <code>```html</code> block so that the caller still receives something renderable. The function therefore never raises.</p><div class="odoc-spec"><div class="spec value anchored" id="val-crawl"><a href="#val-crawl" class="anchor"></a><code><span><span class="keyword">val</span> crawl : 
  <span><span class="label">root</span>:<span><span>[&gt; <span class="xref-unresolved">Eio__</span>.Fs.dir_ty ]</span> <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?filter</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="label">pkg</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span class="label">doc_path</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span class="label">markdown</span>:string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>crawl root ?filter f</code> recursively scans the documentation tree rooted at <code>root</code> and calls <code>f</code> for every document discovered.</p><p>It treats every *sub-directory* of <code>root</code> as a separate opam package (identified by the directory's basename). Within each package the following items are considered:</p><p>â€¢ HTML pages â€“ files ending in <code>.html</code>. Pages whose body contains the phrase &quot;This module is hidden.&quot; are ignored because odoc uses this string for modules that are not part of the public API.</p><p>â€¢ Package README inside an <code>_doc-dir</code> directory. Files recognised by <a href="#val-is_readme_md"><code>is_readme_md</code></a> are forwarded *unmodified* as Markdown.</p><p>For HTML input <a href="#val-markdown_of_html"><code>markdown_of_html</code></a> is used to convert the page to Markdown before invoking the callback.</p><p>The traversal is performed synchronously per directory but individual entries in a directory are processed concurrently using <code>Eio.Fiber.List.iter</code> with up to 25 fibers. A similar limit is used on the top-level enumeration of packages.</p><p>The implementation is *best-effort*:</p><p>â€¢ Files or directories that cannot be accessed are silently skipped. â€¢ Exceptions raised by the user-supplied callback <code>f</code> are propagated, but all other failures (e.g. HTML parsing) are logged with <a href="../Log/index.html#val-emit"><code>Log.emit</code></a> and ignored.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">root</span> <p>Filesystem location of the directory produced by <code>dune build @doc</code> or <code>odoc compile-pkg</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">filter</span> <p>Optional predicate applied to directory names at the *package* level. A package whose basename fails the predicate is skipped entirely. Defaults to a function that always returns <code>true</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">f</span> <p>User callback receiving the package name, the path of the document relative to <code>root</code>, and the converted Markdown string.</p></li></ul><p>Example</p><p>See the module-level example above for a complete program.</p></div></div></div></body></html>
