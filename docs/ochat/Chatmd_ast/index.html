<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chatmd_ast (ochat.Chatmd_ast)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Chatmd_ast</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Chatmd_ast</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#design-choices">Design choices</a></li><li><a href="#quick-example">Quick example</a></li></ul></nav></div><div class="odoc-content"><p>Chatmd_ast ‚Äî typed representation of *ChatMarkdown* documents.</p><p>The module defines a **minimal DOM**: only the *official* ChatMarkdown elements are represented as distinct constructors; *all other* markup is folded into plain <code>`Text`</code> nodes by <a href="../Chatmd_lexer/index.html"><code>Chatmd_lexer</code></a>. The goal is to keep the structure lightweight while still allowing programmatic inspection of the parts that matter to the application (e.g. differentiating a user message from a tool call).</p><h2 id="design-choices"><a href="#design-choices" class="anchor"></a>Design choices</h2><p>‚Ä¢ **No full XML fidelity** ‚Äì we purposefully ignore namespaces, comments and processing instructions. If such constructs appear inside a known element they will be preserved verbatim in a <code>`Text`</code> node so that no information is lost.</p><p>‚Ä¢ **No position tracking** ‚Äì the AST stores only semantic information. When error reporting is required the lexer and parser embed the location in their error messages instead.</p><p>‚Ä¢ **S-expression converters** ‚Äì all public types derive <code>`sexp_of`</code> and <code>`t_of_sexp`</code> using `<code>@@deriving sexp</code>`, simplifying debugging and unit testing.</p><h2 id="quick-example"><a href="#quick-example" class="anchor"></a>Quick example</h2><pre class="language-ocaml"><code>  open Chatmd_ast

  let doc : document =
    [ Element
        ( Msg, [ &quot;role&quot;, Some &quot;user&quot; ],
          [ Text &quot;Hello&quot; ] ) ]

  let () =
    Sexp.pp_hum Format.std_formatter (sexp_of_document doc)</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-tag"><a href="#type-tag" class="anchor"></a><code><span><span class="keyword">type</span> tag</span><span> = </span></code><ol><li id="type-tag.Msg" class="def variant constructor anchored"><a href="#type-tag.Msg" class="anchor"></a><code><span>| </span><span><span class="constructor">Msg</span></span></code></li><li id="type-tag.User" class="def variant constructor anchored"><a href="#type-tag.User" class="anchor"></a><code><span>| </span><span><span class="constructor">User</span></span></code></li><li id="type-tag.Agent" class="def variant constructor anchored"><a href="#type-tag.Agent" class="anchor"></a><code><span>| </span><span><span class="constructor">Agent</span></span></code></li><li id="type-tag.Assistant" class="def variant constructor anchored"><a href="#type-tag.Assistant" class="anchor"></a><code><span>| </span><span><span class="constructor">Assistant</span></span></code></li><li id="type-tag.System" class="def variant constructor anchored"><a href="#type-tag.System" class="anchor"></a><code><span>| </span><span><span class="constructor">System</span></span></code></li><li id="type-tag.Developer" class="def variant constructor anchored"><a href="#type-tag.Developer" class="anchor"></a><code><span>| </span><span><span class="constructor">Developer</span></span></code></li><li id="type-tag.Doc" class="def variant constructor anchored"><a href="#type-tag.Doc" class="anchor"></a><code><span>| </span><span><span class="constructor">Doc</span></span></code></li><li id="type-tag.Img" class="def variant constructor anchored"><a href="#type-tag.Img" class="anchor"></a><code><span>| </span><span><span class="constructor">Img</span></span></code></li><li id="type-tag.Import" class="def variant constructor anchored"><a href="#type-tag.Import" class="anchor"></a><code><span>| </span><span><span class="constructor">Import</span></span></code></li><li id="type-tag.Config" class="def variant constructor anchored"><a href="#type-tag.Config" class="anchor"></a><code><span>| </span><span><span class="constructor">Config</span></span></code></li><li id="type-tag.Reasoning" class="def variant constructor anchored"><a href="#type-tag.Reasoning" class="anchor"></a><code><span>| </span><span><span class="constructor">Reasoning</span></span></code></li><li id="type-tag.Summary" class="def variant constructor anchored"><a href="#type-tag.Summary" class="anchor"></a><code><span>| </span><span><span class="constructor">Summary</span></span></code></li><li id="type-tag.Tool_call" class="def variant constructor anchored"><a href="#type-tag.Tool_call" class="anchor"></a><code><span>| </span><span><span class="constructor">Tool_call</span></span></code></li><li id="type-tag.Tool_response" class="def variant constructor anchored"><a href="#type-tag.Tool_response" class="anchor"></a><code><span>| </span><span><span class="constructor">Tool_response</span></span></code></li><li id="type-tag.Tool" class="def variant constructor anchored"><a href="#type-tag.Tool" class="anchor"></a><code><span>| </span><span><span class="constructor">Tool</span></span></code></li></ol></div><div class="spec-doc"><p>Enumeration of ChatMarkdown element names.</p><p>The set is **closed** ‚Äì any unknown tag encountered by the lexer will be treated as raw text. Values follow the exact lower-case strings produced by the language (e.g. <code>`Msg`</code> corresponds to `&lt;msg&gt;`).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tag_of_sexp"><a href="#val-tag_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> tag_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-tag">tag</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_tag"><a href="#val-sexp_of_tag" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_tag : <span><a href="#type-tag">tag</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tag_equal"><a href="#val-tag_equal" class="anchor"></a><code><span><span class="keyword">val</span> tag_equal : <span><a href="#type-tag">tag</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tag">tag</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>tag_equal a b</code> returns <code>true</code> iff tags <code>a</code> and <code>b</code> are identical.</p><p>This is a specialised equality that avoids relying on structural comparison so that the implementation can remain stable should we ever attach payloads to the variant constructors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tag_of_string_opt"><a href="#val-tag_of_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> tag_of_string_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tag">tag</a> option</span></span></code></div><div class="spec-doc"><p><code>tag_of_string_opt s</code> converts the lower-case tag name <code>s</code> to the corresponding <a href="#type-tag"><code>tag</code></a>. Returns <code>Some _</code> when <code>s</code> is recognised, or <code>None</code> otherwise. The function expects the exact canonical spelling ‚Äì no normalisation other than case‚Äêsensitivity is performed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tag_of_string"><a href="#val-tag_of_string" class="anchor"></a><code><span><span class="keyword">val</span> tag_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-tag">tag</a></span></code></div><div class="spec-doc"><p><code>tag_of_string s</code> behaves like <a href="#val-tag_of_string_opt"><code>tag_of_string_opt</code></a> but raises <code>Invalid_argument</code> instead of returning <code>None</code> when the input is unrecognised.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>s</code> is not a valid ChatMarkdown tag name.</p></li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-attribute"><a href="#type-attribute" class="anchor"></a><code><span><span class="keyword">type</span> attribute</span><span> = string * <span>string option</span></span></code></div><div class="spec-doc"><p>XML‚Äêstyle attribute represented as <code>(name, value)</code>.</p><p>‚Ä¢ <code>name</code> ‚Äì raw attribute key, *case‚Äêsensitive*. ‚Ä¢ <code>value</code> ‚Äì <code>Some v</code> when a value is supplied (quotes are stripped and entities are decoded by the lexer) or <code>None</code> for bare attributes such as <code>disabled</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-attribute_of_sexp"><a href="#val-attribute_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> attribute_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-attribute">attribute</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_attribute"><a href="#val-sexp_of_attribute" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_attribute : <span><a href="#type-attribute">attribute</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> node</span><span> = </span></code><ol><li id="type-node.Element" class="def variant constructor anchored"><a href="#type-node.Element" class="anchor"></a><code><span>| </span><span><span class="constructor">Element</span> <span class="keyword">of</span> <a href="#type-tag">tag</a> * <span><a href="#type-attribute">attribute</a> list</span> * <span><a href="#type-node">node</a> list</span></span></code></li><li id="type-node.Text" class="def variant constructor anchored"><a href="#type-node.Text" class="anchor"></a><code><span>| </span><span><span class="constructor">Text</span> <span class="keyword">of</span> string</span></code></li></ol></div><div class="spec-doc"><p>Polymorphic tree representation.</p><p>‚Ä¢ <code>Element (tag, attrs, children)</code> ‚Äì a recognised ChatMarkdown element. Unknown nested markup is already collapsed into a single <code>`Text`</code> inside <code>children</code>.</p><p>‚Ä¢ <code>Text s</code> ‚Äì raw character data as it appeared in the source, with HTML entities *decoded* by the lexer. New-lines and insignificant spaces are preserved because layout can carry semantic meaning in LLM prompts.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-node_of_sexp"><a href="#val-node_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> node_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_node"><a href="#val-sexp_of_node" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_node : <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-document"><a href="#type-document" class="anchor"></a><code><span><span class="keyword">type</span> document</span><span> = <span><a href="#type-node">node</a> list</span></span></code></div><div class="spec-doc"><p>A complete ChatMarkdown document ‚Äì it is simply a list of top‚Äêlevel elements. Pure whitespace between elements is discarded by the parser and therefore never appears in the AST.</p></div></div></div></body></html>
