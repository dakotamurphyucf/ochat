<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mcp_client (ochat.Mcp_client)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Mcp_client</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Mcp_client</span></code></h1><p>High-level MCP client (non-blocking).</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#design">Design</a></li><li><a href="#supported-transports">Supported transports</a></li><li><a href="#concurrency-model">Concurrency model</a></li></ul></nav></div><div class="odoc-content"><h2 id="design"><a href="#design" class="anchor"></a>Design</h2><p>The client opens **one underlying transport connection** (currently either <a href="../Mcp_transport_stdio/index.html"><code>Mcp_transport_stdio</code></a> or <a href="../Mcp_transport_http/index.html"><code>Mcp_transport_http</code></a>) and starts a dedicated *receiver fibre*. The fibre continuously reads JSON-RPC packets, parses them with <a href="../Mcp_types/Jsonrpc/index.html"><code>Mcp_types.Jsonrpc</code></a>, and then:</p><p>â€¢ *Responses* â€“ matched to a promise resolver stored in a per-request hash-table; the corresponding <code>Eio.Promise.t</code> is then resolved. â€¢ *Notifications* â€“ forwarded verbatim to <a href="#val-notifications"><code>notifications</code></a> so that callers can subscribe if needed.</p><p>All helpers therefore come in two flavours:</p><p>â€¢ <code>`*_async`</code> â€“ fire-and-forget functions that return an <code>`('a, string) result Eio.Promise.t`</code> immediately. â€¢ *blocking wrappers* (`list_tools`, `call_tool`, â€¦) that simply <code>Eio.Promise.await</code> the asynchronous variant and expose a regular <code>('a, string) result</code>.</p><h2 id="supported-transports"><a href="#supported-transports" class="anchor"></a>Supported transports</h2><p>The URI passed to <a href="#val-connect"><code>connect</code></a> selects the transport:</p><p>â€¢ &quot;stdio:&lt;command&gt;&quot; â€“ spawn a local process and communicate over JSON lines on stdin/stdout. â€¢ Any `http` / `https` (or `mcp+http/https`) URI â€“ experimental streamable HTTP transport.</p><p>Additional transports can be added without changing the public API.</p><h2 id="concurrency-model"><a href="#concurrency-model" class="anchor"></a>Concurrency model</h2><p>â€¢ **Thread-safe** â€“ all public functions may be called concurrently from multiple fibres. â€¢ **Single outstanding resolver per request id** â€“ the client guarantees that at most one resolver is stored for any <a href="../Mcp_types/Jsonrpc/Id/index.html#type-t"><code>Mcp_types.Jsonrpc.Id.t</code></a>. â€¢ **Cancellation** â€“ closing the underlying <code>transport</code> will cause all awaiting fibres to fail with <code>Connection_closed</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : 
  <span><span class="optlabel">?auth</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">sw</span>:<span class="xref-unresolved">Eio</span>.Switch.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>connect ?auth ~sw ~env uri</code> opens a new connection to the MCP server designated by <code>uri</code> and returns a fresh client handle.</p><p>The function performs the mandatory <code>initialize</code>/<code>initialized</code> JSON-RPC handshake *synchronously* before it returns; once the promise is fulfilled the returned client is ready to accept requests.</p><p>Parameters: â€¢ <code>?auth</code> â€“ set to <code>false</code> to disable transport-level authentication (default = <code>true</code>). â€¢ <code>sw</code> â€“ switch whose lifetime bounds the client; closing the switch closes the connection and cancels all pending promises. â€¢ <code>env</code> â€“ <code>Eio_unix.Stdenv.base</code> passed to the transport (used for spawning processes, opening sockets, â€¦). â€¢ <code>uri</code> â€“ transport-selecting identifier (see module doc).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../Mcp_transport_stdio/index.html#exception-Connection_closed"><code>Mcp_transport_stdio.Connection_closed</code></a> <p>if the stdio transport terminates before the handshake completes.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../Mcp_transport_http/index.html#exception-Connection_closed"><code>Mcp_transport_http.Connection_closed</code></a> <p>for the HTTP transport.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> closes the underlying transport. Further calls to any function except <a href="#val-is_closed"><code>is_closed</code></a> will raise <code>Connection_closed</code>. Safe to call multiple times.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> is <code>true</code> once <a href="#val-close"><code>close</code></a> has been called or the server has unexpectedly terminated.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rpc_async"><a href="#val-rpc_async" class="anchor"></a><code><span><span class="keyword">val</span> rpc_async : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Mcp_types/Jsonrpc/index.html#type-request">Mcp_types.Jsonrpc.request</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="xref-unresolved">Jsonaf</span>.t, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Eio</span>.Promise.t</span></span></code></div><div class="spec-doc"><p><code>rpc_async t req</code> sends the JSON-RPC <code>req</code> and returns a promise that resolves with the *matching* result once it arrives.</p><p>The promise is resolved with: â€¢ <code>Ok json</code> â€“ the <code>result</code> field of the response. â€¢ <code>Error msg</code> â€“ if the server responded with an <code>error</code> object or if the response could not be parsed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rpc"><a href="#val-rpc" class="anchor"></a><code><span><span class="keyword">val</span> rpc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Mcp_types/Jsonrpc/index.html#type-request">Mcp_types.Jsonrpc.request</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="xref-unresolved">Jsonaf</span>.t, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rpc t req</code> is a blocking wrapper around <a href="#val-rpc_async"><code>rpc_async</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_tools_async"><a href="#val-list_tools_async" class="anchor"></a><code><span><span class="keyword">val</span> list_tools_async : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../Mcp_types/Tool/index.html#type-t">Mcp_types.Tool.t</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Eio</span>.Promise.t</span></span></code></div><div class="spec-doc"><p><code>list_tools_async t</code> queries the serverâ€™s tool registry and returns a promise with the list of declared tools.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_tools"><a href="#val-list_tools" class="anchor"></a><code><span><span class="keyword">val</span> list_tools : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Mcp_types/Tool/index.html#type-t">Mcp_types.Tool.t</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>list_tools t</code> is the blocking version of <a href="#val-list_tools_async"><code>list_tools_async</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call_tool_async"><a href="#val-call_tool_async" class="anchor"></a><code><span><span class="keyword">val</span> call_tool_async : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">arguments</span>:<span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Mcp_types/Tool_result/index.html#type-t">Mcp_types.Tool_result.t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Eio</span>.Promise.t</span></span></code></div><div class="spec-doc"><p><code>call_tool_async t ~name ~arguments</code> invokes the remote tool <code>name</code> with the given JSON <code>arguments</code> and returns a promise that resolves to the decoded <a href="../Mcp_types/Tool_result/index.html#type-t"><code>Mcp_types.Tool_result.t</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call_tool"><a href="#val-call_tool" class="anchor"></a><code><span><span class="keyword">val</span> call_tool : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">arguments</span>:<span class="xref-unresolved">Jsonaf</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Mcp_types/Tool_result/index.html#type-t">Mcp_types.Tool_result.t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>call_tool</code> is the blocking wrapper around <a href="#val-call_tool_async"><code>call_tool_async</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-notifications"><a href="#val-notifications" class="anchor"></a><code><span><span class="keyword">val</span> notifications : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Mcp_types/Jsonrpc/index.html#type-notification">Mcp_types.Jsonrpc.notification</a> <span class="xref-unresolved">Eio</span>.Stream.t</span></span></code></div><div class="spec-doc"><p><code>notifications t</code> is a bounded <code>Eio.Stream.t</code> that receives every *raw* JSON-RPC notification sent by the server. Callers can attach their own consumer fibres if they need side-band events.</p></div></div></div></body></html>
