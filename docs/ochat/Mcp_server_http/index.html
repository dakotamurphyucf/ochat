<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mcp_server_http (ochat.Mcp_server_http)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Mcp_server_http</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Mcp_server_http</span></code></h1><p>Streamable HTTP transport for the MCP server.</p><p>This module exposes the registry in <a href="../Mcp_server_core/index.html"><code>Mcp_server_core</code></a> over HTTP. It speaks JSON-RPC 2.0 on the request / response level and uses Server-Sent Events (SSE) for bidirectional streaming:</p><ul><li>**Client â†’ Server** â€“ a `POST /mcp` request carries either a single JSON-RPC envelope or a batch (JSON array). If the client advertises `Accept: text/event-stream` every response is streamed as its own SSE event. Otherwise a regular `application/json` body is returned.</li></ul><ul><li>**Server â†’ Client** â€“ a long-lived `GET /mcp` request establishes an SSE channel used by the server to push asynchronous notifications such as `notifications/*/list_changed`, progress updates and structured log messages.</li></ul></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#endpoints">Endpoints</a></li><li><a href="#sessions">Sessions</a></li><li><a href="#authentication">Authentication</a></li><li><a href="#failure-mapping">Failure mapping</a></li><li><a href="#concurrency-model">Concurrency model</a></li></ul></nav></div><div class="odoc-content"><h2 id="endpoints"><a href="#endpoints" class="anchor"></a>Endpoints</h2><p>â€¢ `POST /mcp` â€“ JSON-RPC request batch, optional SSE response.</p><p>â€¢ `GET /mcp` â€“ SSE channel for server-initiated notifications (requires a valid `Mcp-Session-Id` request header).</p><p>â€¢ Standard OAuth2 helper endpoints exposed by <a href="../Oauth2_server_routes/index.html"><code>Oauth2_server_routes</code></a> are also registered when <code>require_auth</code> is <code>true</code>.</p><h2 id="sessions"><a href="#sessions" class="anchor"></a>Sessions</h2><p>A successful <code>`initialize`</code> request creates a fresh, cryptographically random session identifier. The value is returned in the `Mcp-Session-Id` response header and must be echoed by subsequent requests in the same header.</p><h2 id="authentication"><a href="#authentication" class="anchor"></a>Authentication</h2><p>Bearer-token validation is enforced by default. Pass <code>~require_auth:false</code> to <code>run</code> to turn the check off during local development or automated tests.</p><h2 id="failure-mapping"><a href="#failure-mapping" class="anchor"></a>Failure mapping</h2><p>| Problem | HTTP | Body | |----------------------------------|------|----------------------------------------| | Malformed JSON | 400 | <code>&quot;error&quot;:&quot;Invalid JSON&quot;</code> | | Missing / unknown session id | 404 | <code>&quot;error&quot;:&quot;Missing or unknown session id&quot;</code> | | Authentication failure | 401 | <code>&quot;error&quot;:&quot;unauthorized&quot;</code> | | Unsupported HTTP method / path | 405 | &quot;Method Not Allowed&quot; (plain-text) |</p><h2 id="concurrency-model"><a href="#concurrency-model" class="anchor"></a>Concurrency model</h2><p>The HTTP server runs inside a single Eio domain. Piaf spawns one fibre per incoming connection so state is protected by the OCaml runtime lock and no explicit synchronisation is required.</p><p><code>run ?require_auth ~env ~core ~port</code> starts the HTTP listener on <code>127.0.0.1:port</code> and never returns.</p><p>Parameters:</p><ul><li><code>env</code> â€“ current Eio standard environment (obtained from <code>Eio_main.run</code>).</li><li><code>core</code> â€“ shared registry created via <a href="../Mcp_server_core/index.html#val-create"><code>Mcp_server_core.create</code></a>.</li><li><code>port</code> â€“ TCP port to listen on (IPv4 loopback).</li><li><code>?require_auth</code> â€“ enforce bearer-token validation (default <code>true</code>).</li></ul><p>One fibre is forked for each incoming request.</p><p>Example running a development server on port 8080 without authentication:</p><pre class="language-ocaml"><code> Eio_main.run @@ fun env -&gt;
   let registry = Mcp_server_core.create () in
   Mcp_server_http.run ~require_auth:false ~env ~core:registry ~port:8080 </code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="optlabel">?require_auth</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">core</span>:<a href="../Mcp_server_core/index.html#type-t">Mcp_server_core.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">port</span>:int <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div></div></body></html>
