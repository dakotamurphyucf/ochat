<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vector_db (ochat.Vector_db)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Vector_db</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Vector_db</span></code></h1><p>Dense vector search utilities.</p><p>A <b>vector database</b> maps small pieces of text (code snippets, README paragraphs, commit messages, â€¦) to dense float embeddings and offers fast similarity search. This implementation keeps the whole corpus in memory â€“ every document embedding is stored as a <em>column</em> of an Owl matrix â€“ and therefore targets small-to-medium corpora (up to a few hundred thousand fragments on a typical developer machine).</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#data-model">Data model</a></li><li><a href="#supported-operations">Supported operations</a></li></ul></nav></div><div class="odoc-content"><h2 id="data-model"><a href="#data-model" class="anchor"></a>Data model</h2><p>â€¢ <code>t</code> â€“ immutable snapshot: a normalised embedding matrix <a href="#type-t.corpus"><code>corpus</code></a> together with the reverse lookup table <a href="#type-t.index"><code>index</code></a> that maps matrix columns back to the on-disk document id and its token length.</p><p>â€¢ <a href="Vec/index.html"><code>Vec</code></a> â€“ serialisable record bundling a documentâ€™s identifier, token length and raw float-array embedding.</p><h2 id="supported-operations"><a href="#supported-operations" class="anchor"></a>Supported operations</h2><p>â€¢ Build a snapshot from an array of <a href="Vec/index.html#type-t"><code>Vec.t</code></a> (<a href="#val-create_corpus"><code>create_corpus</code></a>).</p><p>â€¢ Retrieve the <code>k</code> most similar documents for a given embedding via cosine similarity (<a href="#val-query"><code>query</code></a>).</p><p>â€¢ Hybrid retrieval that linearly interpolates BM25 with vector similarity (<a href="#val-query_hybrid"><code>query_hybrid</code></a>).</p><p>â€¢ Lazy loading: read an existing snapshot from disk (<a href="#val-initialize"><code>initialize</code></a>) and resolve the matching document bodies (<a href="#val-get_docs"><code>get_docs</code></a>).</p><p>All public functions execute in the callerâ€™s fibre; blocking I/O is performed through Eioâ€™s non-blocking API.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.corpus" class="def record field anchored"><a href="#type-t.corpus" class="anchor"></a><code><span>corpus : <span class="xref-unresolved">Owl</span>.Mat.mat;</span></code></li><li id="type-t.index" class="def record field anchored"><a href="#type-t.index" class="anchor"></a><code><span>index : <span><span>(int, string * int)</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>In-memory snapshot of an embedding corpus.</p><p><code>corpus</code> is an `n Ã— m` Owl matrix whose columns are length-1 (L2 normalised) embeddings. <code>index</code> maps a column number back to the original document identifier and its token length (used for length penalties and for fetching the document from disk).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Vec"><a href="#module-Vec" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Vec/index.html">Vec</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_corpus"><a href="#val-create_corpus" class="anchor"></a><code><span><span class="keyword">val</span> create_corpus : <span><span><a href="Vec/index.html#type-t">Vec.t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create_corpus docs</code> builds a new snapshot from raw embeddings.</p><p>Each element of <code>docs</code> is L2-normalised and appended as a column of the resulting matrix; the original float array is not mutated. The function guarantees:</p><p>â€¢ every column of the returned <code>corpus</code> has unit L2-norm; â€¢ <code>Hashtbl.length index = Array.length docs</code>.</p><p>The operation is O(nÂ·d) where n is the number of documents and d is the embedding dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query"><a href="#val-query" class="anchor"></a><code><span><span class="keyword">val</span> query : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Owl</span>.Mat.mat <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div><div class="spec-doc"><p><code>query t embedding k</code> returns the indices of the <code>k</code> neighbours that maximise cosine similarity to <code>embedding</code>.</p><p><code>embedding</code> must already be L2-normalised and shaped as an n&amp;nbsp;Ã—&amp;nbsp;1 Owl matrix where n equals the embedding dimension of the corpus. If <code>k</code> exceeds the corpus size the result is clamped.</p><p>The function allocates O(m) where m = corpus size. It performs no heap allocations proportional to the embedding dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-query_hybrid"><a href="#val-query_hybrid" class="anchor"></a><code><span><span class="keyword">val</span> query_hybrid : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">bm25</span>:<a href="../Bm25/index.html#type-t">Bm25.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">beta</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">embedding</span>:<span class="xref-unresolved">Owl</span>.Mat.mat <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">text</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">k</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>int array</span></span></code></div><div class="spec-doc"><p><code>query_hybrid t ~bm25 ~beta ~embedding ~text ~k</code> combines dense and lexical search.</p><p>1. Cosine similarities between <code>embedding</code> and the whole corpus are computed. 2. The top 20Â·k candidates form a shortlist. 3. BM25 scores for <code>text</code> are evaluated on the same shortlist. 4. Final score = (1&amp;nbsp;âˆ’&amp;nbsp;Î²)Â·cos + Î²Â·normalised&amp;nbsp;BM25 and the best <code>k</code> hits are returned.</p><p><code>beta</code> âˆˆ <code>0, 1</code> controls the trade-off (0 = vector-only, 1 = BM25-only).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_doc"><a href="#val-add_doc" class="anchor"></a><code><span><span class="keyword">val</span> add_doc : <span><span class="xref-unresolved">Owl</span>.Mat.mat <span class="arrow">&#45;&gt;</span></span> <span><span>float array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Owl</span>.Mat.mat</span></code></div><div class="spec-doc"><p><code>add_doc corpus vec</code> returns <code>corpus</code> with <code>vec</code> appended as the last column.</p><p><code>vec</code> is L2-normalised on the fly; the original array is not modified. The function is a convenience helper for incremental updates â€“ it does <b>not</b> update any <a href="#type-t.index"><code>index</code></a> mapping. Callers are responsible for persisting the extended mapping themselves.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-initialize"><a href="#val-initialize" class="anchor"></a><code><span><span class="keyword">val</span> initialize : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>initialize path</code> reads a previously serialised array of <a href="Vec/index.html#type-t"><code>Vec.t</code></a> from <code>path</code> and builds a snapshot via <a href="#val-create_corpus"><code>create_corpus</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_docs"><a href="#val-get_docs" class="anchor"></a><code><span><span class="keyword">val</span> get_docs : <span><span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>get_docs dir t idxs</code> loads the bodies of the documents with indices <code>idxs</code>.</p><p>For every index the associated file path is looked up in <code>t.index</code> and the file is read with <a href="../Io/index.html#val-load_doc"><code>Io.load_doc</code></a>. The result list preserves the order of <code>idxs</code>.</p></div></div></div></body></html>
