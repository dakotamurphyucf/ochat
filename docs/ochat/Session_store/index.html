<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Session_store (ochat.Session_store)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ochat</a> &#x00BB; Session_store</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Session_store</span></code></h1><p>Session persistence helper.</p><p>`Session_store` wires the <code>`Session`</code>(session.mli) data structure to the file-system. It decides where sessions live (`$HOME/.ochat/sessions/&lt;id&gt;`), takes care of *schema migrations* when a stored snapshot was produced by an older binary, and provides a couple of convenience functions that the CLI surfaces as flags â€“ reset, rebuild, and list.</p><p>The API is deliberately minimal: open a session with <a href="#val-load_or_create"><code>load_or_create</code></a>, mutate the resulting <a href="../Session/index.html#type-t"><code>Session.t</code></a>, then persist it with <a href="#val-save"><code>save</code></a>. All helpers require an `Eio_unix.Stdenv.base` capability so they work equally well in the main thread or inside a fibre/domain.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-id"><a href="#type-id" class="anchor"></a><code><span><span class="keyword">type</span> id</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <span><span class="xref-unresolved">Eio</span>.Fs.dir_ty <span class="xref-unresolved">Eio</span>.Path.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-base_dir"><a href="#val-base_dir" class="anchor"></a><code><span><span class="keyword">val</span> base_dir : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>base_dir ()</code> yields the root directory that stores *all* persisted chat sessions.</p><p>Resolution rules: â€¢ <code>$HOME</code> present â€’ returns <code>&quot;$HOME/.ochat/sessions&quot;</code>. â€¢ otherwise â€’ returns <code>&quot;./.ochat/sessions&quot;</code>.</p><p>Pure helper â€“ it merely constructs the path string and never touches the file-system.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rel_path"><a href="#val-rel_path" class="anchor"></a><code><span><span class="keyword">val</span> rel_path : <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>rel_path id</code> concatenates <a href="#val-base_dir"><code>base_dir</code></a> with <code>id</code> and returns the session directory as a plain string (no capability attached).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ensure_dir"><a href="#val-ensure_dir" class="anchor"></a><code><span><span class="keyword">val</span> ensure_dir : <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div><div class="spec-doc"><p><code>ensure_dir ~env id</code> returns an <code>`dir Path.t</code> rooted at the session directory <code>id</code>, creating the hierarchy recursively with permissions <code>0o700</code> when necessary.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path"><a href="#val-path" class="anchor"></a><code><span><span class="keyword">val</span> path : <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load_or_create"><a href="#val-load_or_create" class="anchor"></a><code><span><span class="keyword">val</span> load_or_create : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">prompt_file</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?id</span>:<a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?new_session</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="../Session/index.html#type-t">Session.t</a></span></code></div><div class="spec-doc"><p><code>load_or_create ~env ~prompt_file ?id ?new_session ()</code> restores an existing session *or* boot-straps a brand-new <a href="../Session/index.html#type-t"><code>Session.t</code></a> when no compatible snapshot is present.</p><p>Identifier selection (highest priority first): 1. explicit <code>?id</code> when <code>new_session = false</code>; 2. freshly generated UUID-v4 when <code>new_session = true</code>; 3. MD5 digest of <code>prompt_file</code> (default).</p><p>If <code>snapshot.bin</code> exists under the chosen directory it is loaded and migrated to the latest schema via <a href="../Session/Legacy/index.html"><code>Session.Legacy</code></a>. Otherwise a new record is created and the original markdown prompt is copied into the directory as <code>prompt.chatmd</code> to keep the session self-contained.</p><p>The returned value lives purely in memory â€“ call <a href="#val-save"><code>save</code></a> after making changes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-save"><a href="#val-save" class="anchor"></a><code><span><span class="keyword">val</span> save : <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span> <span><a href="../Session/index.html#type-t">Session.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>save ~env session</code> atomically writes <code>session</code> to <code>&lt;session-dir&gt;/snapshot.bin</code> while holding an advisory lock file (`snapshot.bin.lock`). The program exits with status 1 when the lock is already taken by another process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-id">id</a> * string)</span> list</span></span></code></div><div class="spec-doc"><p><code>list ~env</code> enumerates *valid* sessions â€“ i.e. directories that contain a readable <code>snapshot.bin</code>. The function returns <code>(id, prompt_file)</code> pairs and silently ignores damaged snapshots.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset_session"><a href="#val-reset_session" class="anchor"></a><code><span><span class="keyword">val</span> reset_session : 
  <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">id</span>:<a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?prompt_file</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?keep_history</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>reset_session ~env ~id ?prompt_file ()</code> archives the current snapshot of session <code>id</code> and resets its in-memory state.</p><p>Behaviour: â€¢ The existing <code>snapshot.bin</code> is moved to an <code>archive/</code> subdirectory of the session directory using the timestamp format &quot;YYYYMMDD-HHMM.snapshot.bin&quot;. â€¢ The loaded session value is passed through <a href="../Session/index.html#val-reset"><code>Session.reset</code></a>, which clears the history and (optionally) updates the <code>prompt_file</code>. â€¢ When <code>prompt_file</code> is provided, the referenced markdown document is copied into the session directory as <code>prompt.chatmd</code> and recorded via <code>local_prompt_copy</code>. â€¢ The new snapshot is then written back to disk via <a href="#val-save"><code>save</code></a>.</p><p>The helper prints a short confirmation message on <code>stdout</code>. It exits early with an error message if the session cannot be found.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rebuild_session"><a href="#val-rebuild_session" class="anchor"></a><code><span><span class="keyword">val</span> rebuild_session : <span><span class="label">env</span>:<span class="xref-unresolved">Eio_unix</span>.Stdenv.base <span class="arrow">&#45;&gt;</span></span> <span><span class="label">id</span>:<a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rebuild_session ~env ~id ()</code> discards the current <code>snapshot.bin</code> of session <code>id</code> and recreates a fresh one seeded solely by the <i>current</i> prompt file. The helper is intended for the workflow where the user edits the copied <code>prompt.chatmd</code> inside the session directory and wants the persisted session state to reflect those changes without starting the interactive TUI.</p><p>Behaviour: â€¢ The existing snapshot is moved to <code>archive/</code> just like <a href="#val-reset_session"><code>reset_session</code></a>. â€¢ A brand-new <a href="../Session/index.html#type-t"><code>Session.t</code></a> value is created using the same <code>prompt_file</code> and <code>local_prompt_copy</code> recorded in the archived snapshot. The new record therefore has an <b>empty</b> history â€“ the interactive UI will re-parse the updated prompt on the next launch. â€¢ The per-session cache located at <code>&lt;session-dir&gt;/.chatmd/cache.bin</code> is deleted to avoid stale tool outputs. â€¢ A confirmation summary is printed to <code>stdout</code>.</p></div></div></div></body></html>
