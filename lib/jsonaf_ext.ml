open Core

(** Re-export [Jsonaf] and provide Bin_prot converters.

    The binary representation used here is the UTF-8 JSON text generated by
    {!Jsonaf.to_string}; deserialization reverses the process with
    {!Jsonaf.of_string}.  As a result the conversion is lossless provided the
    JSON text itself is preserved.

    These definitions allow you to embed [Jsonaf.t] inside other types using
    [[@@deriving bin_io]].

    {1 Example}

    Serialise a value into a bigstring and read it back:

    {[
      let json  = `Object [ "hello", `String "world" ] in
      let size  = Jsonaf_ext.bin_size_t json in
      let buf   = Bigstring.create size in
      ignore (Jsonaf_ext.bin_write_t buf ~pos:0 json);
      let json' = Jsonaf_ext.bin_read_t buf ~pos_ref:(ref 0) in
      assert (Jsonaf.exactly_equal json json');
    ]}
*)

include Jsonaf (* re-export the full Jsonaf API *)

(* 1 ─ Shape  -------------------------------------------------------- *)

(** Binary shape for {!Jsonaf.t}.  Alias to
    {!Bin_prot.Shape.bin_shape_string} because the on-wire format is simply a
    string. *)

let bin_shape_t = Bin_prot.Shape.bin_shape_string

(* 2 ─ Writer  ------------------------------------------------------- *)

(** [bin_size_t t] returns the size in bytes of the binary encoding produced
    by {!bin_write_t} on [t]. *)

let bin_size_t (t : Jsonaf.t) = Bin_prot.Size.bin_size_string (Jsonaf.to_string t)

(** [bin_write_t buf ~pos t] writes [t]'s binary representation into [buf]
    starting at position [pos] and returns the position just after the last
    byte written. *)

let bin_write_t buf ~pos (t : Jsonaf.t) =
  Bin_prot.Write.bin_write_string buf ~pos (Jsonaf.to_string t)
;;

(** Bin\_prot writer for {!Jsonaf.t}. *)

let bin_writer_t : Jsonaf.t Bin_prot.Type_class.writer =
  { size = bin_size_t; write = bin_write_t }
;;

(* 3 ─ Reader  ------------------------------------------------------- *)

(** [bin_read_t buf ~pos_ref] deserialises a value previously encoded with
    {!bin_write_t}.  The function reads a string using
    {!Bin_prot.Read.bin_read_string} and parses it with {!Jsonaf.of_string}. *)

let bin_read_t buf ~pos_ref =
  let json_txt = Bin_prot.Read.bin_read_string buf ~pos_ref in
  Jsonaf.of_string json_txt
;;

(** Internal variant tag reader required by some low-level [bin_io]
    machinery.  Delegates to {!bin_read_t}. *)

let __bin_read_t__ buf ~pos_ref _len = bin_read_t buf ~pos_ref

(** Bin\_prot reader for {!Jsonaf.t}. *)

let bin_reader_t : Jsonaf.t Bin_prot.Type_class.reader =
  { read = bin_read_t; vtag_read = __bin_read_t__ }
;;

(* 4 ─ Type-class bundle -------------------------------------------- *)

(** Complete Bin\_prot type-class for {!Jsonaf.t}.  Contains {!bin_writer_t},
    {!bin_reader_t} and {!bin_shape_t}. *)

let bin_t : Jsonaf.t Bin_prot.Type_class.t =
  { writer = bin_writer_t; reader = bin_reader_t; shape = bin_shape_t }
;;
