# `Html_to_md` – HTML to Markdown conversion utilities

`Html_to_md` is the heart of the *webpage_markdown* library.  It takes the
messy, real-world HTML you often get back from the web and translates it into
[OMD](https://github.com/ocaml/omd)’s Markdown abstract syntax tree so that it
can be rendered or further processed in OCaml.

Unlike template-oriented converters that assume well-formed input, the module
is intentionally *loss tolerant*: every DOM node that cannot be mapped to a
Markdown construct is preserved as a raw HTML block – no information is
silently thrown away.

---

## High-level workflow

1. **Noise pruning** – obvious non-content tags (`<script>`, `<style>`,
   `<nav>`, *etc.*) and GitHub/GitLab UI chrome are removed.
2. **Main-content isolation** – if an `<article class="markdown-body">` is
   detected the converter keeps only that subtree.  This dramatically improves
   the output of documentation pages generated by *odoc*, GitHub, GitLab and
   similar tools.
3. **HTML → OMD mapping** – the remaining DOM is walked depth-first.  Tags are
   mapped to OMD blocks (*paragraph*, *heading*, *list*, …) or inlines
   (*emphasis*, *code span*, *image*, …).  Where a mapping is unknown the raw
   HTML is kept inside an `Html_block` node.
4. **Rendering** – downstream code can pretty-print the resulting
   `Omd.doc` with `{!Md_render.to_string}` or manipulate the tree further.

The public API is minimal on purpose – only two functions matter:

```ocaml
val convert : Soup.soup Soup.node -> Omd.doc
val to_markdown_string : Soup.soup Soup.node -> string
```

---

## API reference

### `convert`

```ocaml
val convert : Soup.soup Soup.node -> Omd.doc
```

Traverses the given `Soup.soup` and returns a Markdown document.  The
algorithm is *O(n)* in the number of DOM nodes.  Unsupported elements are
wrapped in `Html_block`s so that the resulting tree can be round-tripped back
to HTML if needed.

#### Example

```ocaml
let html  = "<p><em>Hi</em> <strong>there</strong></p>" in
let soup  = Soup.parse html in
let doc   = Html_to_md.convert soup in
Md_render.to_string doc
(* -> "*Hi* **there**" *)
```

### `to_markdown_string`

```ocaml
val to_markdown_string : Soup.soup Soup.node -> string
```

A convenience wrapper around `convert` that immediately renders the AST using
`Md_render.to_string`.  It never raises; if the input cannot be parsed, the
original HTML is returned inside a fenced `html` block so that callers do not
lose data.

#### Example

```ocaml
let md = Html_to_md.to_markdown_string (Soup.parse "<h1>Hello</h1>")
(* md = "# Hello" *)
```

---

## Limitations

* **CSS-driven layouts** – constructs that rely purely on CSS for semantics
  (for example visually hidden headings) cannot be recovered.
* **JavaScript-rendered pages** – if the HTML is generated client-side the
  converter will obviously not see it.  Use the higher-level `driver` module
  which falls back to a headless Chrome dump when it detects an empty result.
* **Tables with complex row/column spans** – to keep the converter simple the
  current implementation ignores `rowspan`/`colspan`.  Such tables fall back
  to raw HTML blocks.

---

## Internals at a glance

* **Noise detection** – heuristics live in `prune_noise` and
  `isolate_main_content`.
* **Inline mapping** – implemented by the mutually recursive
  `inline_of_node` / `inline_children` helpers.
* **Block mapping** – implemented by `safe_block_of_node`, which shields the
  rest of the pipeline from parser exceptions.

You do **not** need to understand these details to use the module but they are
handy if you plan to tweak the behaviour.

---

## See also

* [`Md_render`](./md_render.doc.md) – minimal Markdown pretty-printer used by
  `Html_to_md`.
* [`driver`](./driver.doc.md) – higher-level component that fetches a remote
  URL and applies the converter.

