(** Core types for the Model Context Protocol – minimal client-side subset.

    This signature exposes only the data-structures needed by the Phase-1
    implementation (stdio transport).  All records tolerate unknown JSON
    keys – the [@@jsonaf.allow_extra_fields] annotation in the [.ml] file
    ensures forward-compatibility with richer server payloads. *)

module Jsonrpc : sig
  module Id : sig
    type t =
      | String of string
      | Int of int
    [@@deriving bin_io, equal, compare, sexp]

    val of_int : int -> t
    val of_string : string -> t
    val ( = ) : t -> t -> bool
  end

  type error_obj =
    { code : int
    ; message : string
    ; data : Jsonaf.t option
    }
  [@@deriving jsonaf, sexp, bin_io]

  type request =
    { jsonrpc : string
    ; id : Id.t
    ; method_ : string
    ; params : Jsonaf.t option
    }
  [@@deriving jsonaf, sexp, bin_io]

  type response =
    { jsonrpc : string
    ; id : Id.t
    ; result : Jsonaf.t option
    ; error : error_obj option
    }
  [@@deriving jsonaf, sexp, bin_io]

  type notification =
    { jsonrpc : string
    ; method_ : string
    ; params : Jsonaf.t option
    }
  [@@deriving jsonaf, sexp, bin_io]

  val make_request : ?params:Jsonaf.t -> id:Id.t -> method_:string -> unit -> request
  val ok : id:Id.t -> Jsonaf.t -> response
  val error : id:Id.t -> code:int -> message:string -> ?data:Jsonaf.t -> unit -> response
  val notify : ?params:Jsonaf.t -> method_:string -> unit -> notification

  (*------------------------------------------------------------------
     Low-level Jsonaf conversion helpers generated by ppx_jsonaf_conv.
     We surface only the subset needed by the client for Phase-1.  The
     concrete serialisation details are stable because they follow the
     handwritten record field names above.
  ------------------------------------------------------------------*)
end

  (* Placeholder – detailed resource content wrappers can be added when
     needed by client code.*)

(* removed earlier misplaced definitions; actual ones appear later *)

module Capability : sig
  type list_changed = bool
  type tools_capability = { list_changed : list_changed option }
  type prompts_capability = { list_changed : list_changed option }

  type resources_capability =
    { subscribe : bool option
    ; list_changed : list_changed option
    }
  [@@deriving jsonaf, sexp, bin_io]

  type t =
    { tools : tools_capability option
    ; prompts : prompts_capability option
    ; resources : resources_capability option
    }
  [@@deriving jsonaf, sexp, bin_io]
end

module Tool : sig
  type t =
    { name : string
    ; description : string option
    ; input_schema : Jsonaf.t
    }
  [@@deriving jsonaf, sexp, bin_io]
end

module Tools_list_result : sig
  type t =
    { tools : Tool.t list
    ; next_cursor : string option
    }
  [@@deriving jsonaf, sexp, bin_io]
end

module Tool_result : sig
  type content =
    | Text of string
    | Json of Jsonaf.t
    | Rich of Jsonaf.t

  type t =
    { content : content list
    ; is_error : bool
    }
  [@@deriving jsonaf, sexp, bin_io]
end

(*--------------------------------------------------------------------
  Resource metadata and related result payloads – limited subset needed by
  the current server implementation (resources/list & resources/read).
--------------------------------------------------------------------*)

module Resource : sig
  type t =
    { uri : string
    ; name : string
    ; description : string option
    ; mime_type : string option [@key "mimeType"]
    ; size : int option
    }
  [@@deriving jsonaf]

  val jsonaf_of_t : t -> Jsonaf.t
end
