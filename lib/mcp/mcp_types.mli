(** Model Context Protocol – minimal OCaml bindings.

    This module declares the **client-side** subset of the *Model Context
    Protocol (MCP)* data model that is required by the current
    implementation ("Phase 1", stdio transport only).  Every record is
    equipped with automatic JSON serialisers/deserialisers generated by
    {!ppx_jsonaf_conv}.  Unknown fields are silently ignored thanks to the
    [@@jsonaf.allow_extra_fields] attribute, which makes the bindings
    forward-compatible with future revisions of the server schema.

    {1 Sub-modules}

    • {!module:Jsonrpc} – vanilla JSON-RPC 2.0 envelopes (request,
      response, notification).
    • {!module:Capability} – subset of the MCP capability-negotiation
      object.
    • {!module:Tool} / {!module:Tools_list_result} – metadata returned by
      ["tools/list"].
    • {!module:Tool_result} – wrapper around a tool-call result.
    • {!module:Resource} – very small slice of the resource API that the
      current server supports.

    The implementation purposefully omits many optional fields.  Whenever
    you add a new field on the server side, extend the corresponding record
    here and the JSON (de)serialisation will just work. *)

module Jsonrpc : sig
  module Id : sig
    type t =
      | String of string (** Raw JSON string identifier. *)
      | Int of int (** 32-bit JSON number identifier.        *)
    [@@deriving bin_io, equal, compare, sexp]

    (** [of_int n] returns [Int n].  Provided for symmetry with
        {!of_string}. *)
    val of_int : int -> t

    (** [of_string s] returns [String s]. *)
    val of_string : string -> t

    (** Syntactic sugar for [Id.equal]. *)
    val ( = ) : t -> t -> bool
  end

  type error_obj =
    { code : int (** Error code defined by JSON-RPC/MCP.           *)
    ; message : string (** Human-readable, non-localized message.        *)
    ; data : Jsonaf.t option (** Optional structured payload.                  *)
    }
  [@@deriving jsonaf, sexp, bin_io]

  type request =
    { jsonrpc : string (** Must be the literal ["2.0"]. *)
    ; id : Id.t (** Correlates request ↔ response.     *)
    ; method_ : string (** RPC method name.                   *)
    ; params : Jsonaf.t option (** Optional positional/object params. *)
    }
  [@@deriving jsonaf, sexp, bin_io]

  type response =
    { jsonrpc : string (** Literal ["2.0"].                           *)
    ; id : Id.t (** Mirrors the request ID.                    *)
    ; result : Jsonaf.t option (** Present on success.                        *)
    ; error : error_obj option (** Present on failure. [result] is then [None]. *)
    }
  [@@deriving jsonaf, sexp, bin_io]

  type notification =
    { jsonrpc : string (** ["2.0"]. *)
    ; method_ : string (** Notification name. *)
    ; params : Jsonaf.t option (** Optional payload.   *)
    }
  [@@deriving jsonaf, sexp, bin_io]

  (** [make_request ?params ~id ~method_ ()] constructs a well-formed JSON-RPC
      request envelope with protocol version set to ["2.0"]. *)
  val make_request : ?params:Jsonaf.t -> id:Id.t -> method_:string -> unit -> request

  (** [ok ~id payload] wraps [payload] in a successful response envelope. *)
  val ok : id:Id.t -> Jsonaf.t -> response

  (** [error ~id ~code ~message ?data ()] constructs an error response. *)
  val error : id:Id.t -> code:int -> message:string -> ?data:Jsonaf.t -> unit -> response

  (** [notify ?params ~method_ ()] creates a JSON-RPC notification (no [id]). *)
  val notify : ?params:Jsonaf.t -> method_:string -> unit -> notification

  (*------------------------------------------------------------------
     Low-level Jsonaf conversion helpers generated by ppx_jsonaf_conv.
     We surface only the subset needed by the client for Phase-1.  The
     concrete serialisation details are stable because they follow the
     handwritten record field names above.
  ------------------------------------------------------------------*)
end

(* Placeholder – detailed resource content wrappers can be added when
     needed by client code.*)

(* removed earlier misplaced definitions; actual ones appear later *)

module Capability : sig
  (** Partial representation of the [capabilities] object exchanged during
      session-initialisation.

      Only the keys currently used by the runtime are modelled.  All
      booleans are optional so that the structure remains backward
      compatible with richer server payloads. *)

  (** Convenience alias matching the MCP schema (camel-case → snake_case). *)
  type list_changed = bool

  (** Capabilities under the [tools] key. *)
  type tools_capability = { list_changed : list_changed option }

  (** Capabilities under the [prompts] key. *)
  type prompts_capability = { list_changed : list_changed option }

  type resources_capability =
    { subscribe : bool option (** Whether streaming updates are supported. *)
    ; list_changed : list_changed option
    }
  [@@deriving jsonaf, sexp, bin_io]

  type t =
    { tools : tools_capability option
    ; prompts : prompts_capability option
    ; resources : resources_capability option
    }
  [@@deriving jsonaf, sexp, bin_io]
end

module Tool : sig
  (** Metadata for a single tool as returned by the ["tools/list"] RPC. *)

  type t =
    { name : string (** Fully-qualified tool name.            *)
    ; description : string option (** One-line human description.          *)
    ; input_schema : Jsonaf.t (** JSON Schema describing the input.    *)
    }
  [@@deriving jsonaf, sexp, bin_io]
end

module Tools_list_result : sig
  (** Result envelope for ["tools/list"]. *)

  type t =
    { tools : Tool.t list (** Current page of tools.        *)
    ; next_cursor : string option (** Opaque pagination cursor.     *)
    }
  [@@deriving jsonaf, sexp, bin_io]
end

module Tool_result : sig
  (** Wrapper for the payload returned by a tool invocation.  In the MCP
      wire format this is nested under the [result] key of the JSON-RPC
      response. *)

  type content =
    | Text of string (** UTF-8 string (human-readable). *)
    | Json of Jsonaf.t (** Machine-readable value that is *not* an object. *)
    | Rich of Jsonaf.t (** Structured object defined by the tool author. *)

  type t =
    { content : content list (** Content segments ordered as provided. *)
    ; is_error : bool (** [true] if the tool call failed.     *)
    }
  [@@deriving jsonaf, sexp, bin_io]
end

(*--------------------------------------------------------------------
  Resource metadata and related result payloads – limited subset needed by
  the current server implementation (resources/list & resources/read).
--------------------------------------------------------------------*)

module Resource : sig
  (** Metadata for a single resource returned by ["resources/list"].

      Only the fields actively required by the client are represented.  The
      server is free to attach additional keys; they will be ignored during
      deserialisation. *)

  type t =
    { uri : string (** Globally unique resource URI. *)
    ; name : string (** Display name.                 *)
    ; description : string option (** Optional free-form summary.   *)
    ; mime_type : string option [@key "mimeType"]
      (** Media type (e.g. ["text/plain"], ["image/png"]). *)
    ; size : int option (** Size in bytes, when known.    *)
    }
  [@@deriving jsonaf]

  (** Re-export the auto-generated converter so that callers do not have to
      depend on [Jsonaf_conv]. *)
  val jsonaf_of_t : t -> Jsonaf.t
end
