# `Chatml_lexer` — ChatML lexical analyser

This document complements the inline odoc comments found in
`chatml_lexer.mll` with higher-level usage notes, rationale and
examples.  It targets users who wish to integrate the lexer in their
own tooling (e.g. editor integrations, static analysers) or simply
understand how the ChatML front-end is structured.

> **Note**  The actual implementation is generated by `ocamllex` from
> `chatml_lexer.mll`.  Unless you need to tweak the regular
> expressions, you should **not** edit the produced `chatml_lexer.ml`
> file because it will be overwritten at the next build.

---

## 1. Overview

`Chatml_lexer` converts raw character input into the token stream
expected by the Menhir-generated [`Chatml_parser`](./chatml_parser.mly).
It recognises a deliberately small ML-like syntax featuring:

* Classic keywords: `let`, `in`, `module`, `match`, `fun`, …
* OCaml-style identifiers – both lower-case (`x`, `foo_bar`) and
  upper-case (`Option`, `Foo_bar`)
* Polymorphic variant tags introduced by a backtick <code>`</code>
* Integer, float, boolean and string literals
* A wide range of operators and punctuation symbols
* Nested comments delimited by `(*` … `*)` (again à la OCaml)

Location bookkeeping is delegated to the standard `Lexing` module: the
lexer calls `Lexing.new_line` every time it consumes a newline so that
line/column numbers attached to tokens stay correct throughout the
pipeline.

---

## 2. Public interface

### `val token : Lexing.lexbuf -> Chatml_parser.token`

Primary (and currently only) entry point.  Consumes the next token and
updates the internal cursor of the provided **mutable** lexing buffer.

- **Parameters**
  * `lb` — the mutable lexing buffer to read from.

- **Returns** one of the constructors declared in `Chatml_parser.mly`.
  Constructors that carry a payload (`INT`, `FLOAT`, `STRING`,
  `LIDENT`, `UIDENT`, `TICKIDENT`) already contain the decoded OCaml
  value (e.g. the integer as an `int`).

- **Raises** `Failure` in three situations:
  1. Unknown character (anything that does not match a rule).
  2. Unterminated `(* …` comment.
  3. Unterminated string literal.

The function is tail-recursive and re-entrant: you may call it
recursively from an error-recovery routine as long as you preserve the
same `lexbuf`.

---

## 3. Usage examples

### 3.1 Reading every token until `EOF`

```ocaml
let tokens_of_string (s : string) : Chatml_parser.token list =
  let lb = Lexing.from_string s in
  let rec loop acc =
    match Chatml_lexer.token lb with
    | Chatml_parser.EOF -> List.rev acc
    | tok               -> loop (tok :: acc)
  in
  loop []

let () =
  let ts = tokens_of_string "let x = 1 + 2" in
  List.iter (Chatml_parser.print_token Format.std_formatter) ts
```

### 3.2 Embedding in a Menhir incremental parser

```ocaml
(* Assume you generated an incremental interface with
   menhir --table --incremental chatml_parser.mly *)

let parse (filename : string) : Chatml_lang.stmt_node list =
  let ic = In_channel.create filename in
  let lb = Lexing.from_channel ic in
  let supplier = MenhirLib.LexerUtil.make_supplier Chatml_lexer.token lb in
  let checkpoint = Chatml_parser.Incremental.program lb.lex_curr_p in
  let result = MenhirLib.Engine.stream_checkpoint checkpoint supplier in
  In_channel.close ic;
  result
```

---

## 4. Limitations

1. **Unicode support** — The lexer currently understands only ASCII
   identifiers and escapes.  Input containing UTF-8 encoded non-ASCII
   characters will raise *unknown token* errors.

2. **String escapes** — Only four escapes are decoded (`\n`, `\t`,
   `\\` and `\"`).  Everything else is left verbatim which means the
   interpreter or subsequent compilation phases must deal with them.

3. **Performance** — The implementation relies on `Buffer` and string
   copies for string literals.  This is perfectly adequate for small
   source files but could become a bottleneck when lexing megabyte-
   sized inputs.  Profiling will tell whether optimisation is needed.

---

## 5. Contributing

PRs improving Unicode coverage, adding more string escapes, or fixing
lexical edge cases are very welcome.  The test suite lives in
`test/chatml`.

